<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Uk≈Çad S≈Çoneczny - Naprawione Skakanie</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            height: 100dvh;
        }

        #canvas3d {
            display: block;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
        }

        .ui-overlay {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 100;
            pointer-events: none;
            max-width: 340px;
        }

        .mobile-toggle {
            display: none;
            background: rgba(0,0,0,0.9);
            border: 2px solid rgba(100,181,246,0.6);
            border-radius: 25px;
            padding: 10px 16px;
            color: white;
            font-size: 0.85em;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            text-align: center;
            min-width: 140px;
            font-weight: bold;
        }

        .mobile-toggle:hover {
            background: rgba(0,0,0,0.95);
            border-color: rgba(100,181,246,0.8);
            transform: translateY(-1px);
        }

        .toggle-info {
            font-size: 0.75em;
            color: #64b5f6;
            margin-top: 2px;
        }

        .control-panel {
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 18px;
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            min-width: 300px;
            transition: all 0.3s ease;
            max-height: 85vh;
            overflow-y: auto;
        }

        .control-panel.mobile-collapsed {
            display: none;
        }

        h1 {
            font-size: 1.4em;
            margin: 0 0 5px 0;
            color: #64b5f6;
        }

        .subtitle {
            font-size: 0.85em;
            margin: 0 0 15px 0;
            opacity: 0.8;
            line-height: 1.3;
        }

        .section {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .section h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            color: #64b5f6;
        }

        .time-display {
            text-align: center;
            margin-bottom: 12px;
            font-size: 1em;
            font-weight: bold;
            color: #ffffff;
            background: rgba(100,181,246,0.2);
            padding: 8px;
            border-radius: 8px;
        }

        .slider-container {
            margin: 8px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.85em;
        }

        .slider-value {
            color: #64b5f6;
            font-weight: bold;
        }

        .time-slider, .scale-slider {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .time-slider::-webkit-slider-thumb,
        .scale-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #64b5f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(100,181,246,0.4);
        }

        .time-slider::-moz-range-thumb,
        .scale-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #64b5f6;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .button-row {
            display: flex;
            gap: 6px;
            margin: 12px 0;
            flex-wrap: wrap;
        }

        .control-button {
            background: #64b5f6;
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 20px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            flex: 1;
            min-width: 60px;
        }

        .control-button:hover {
            background: #42a5f5;
            transform: translateY(-1px);
        }

        .reset-button {
            background: #ff9800;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 8px;
            width: 100%;
        }

        .reset-button:hover {
            background: #f57c00;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 12px;
        }

        .info-card {
            background: rgba(255,255,255,0.08);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .info-label {
            font-size: 0.75em;
            opacity: 0.8;
            margin-bottom: 3px;
            line-height: 1.2;
        }

        .info-value {
            font-size: 0.9em;
            font-weight: bold;
            color: #64b5f6;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .ui-overlay {
                top: 10px;
                left: 10px;
                max-width: calc(100vw - 20px);
            }
            
            .mobile-toggle {
                display: block !important;
            }
            
            .control-panel {
                padding: 15px;
                margin-top: 10px;
                min-width: auto;
                width: 100%;
                max-width: calc(100vw - 20px);
                max-height: 70vh;
            }
            
            .info-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
        }

        @media (min-width: 769px) {
            .mobile-toggle {
                display: none !important;
            }
            
            .control-panel {
                display: block !important;
            }
        }

        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8em;
            color: #64b5f6;
            pointer-events: none;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div class="debug-info" id="debugInfo">
        FPS: <span id="fpsDisplay">60</span><br>
        Ziemia: <span id="earthPosDisplay">(0, 0, 0)</span><br>
        Kamera: <span id="cameraPosDisplay">(0, 0, 0)</span>
    </div>

    <div class="ui-overlay">
        <button id="mobileToggle" class="mobile-toggle">
            <div>‚öôÔ∏è Options</div>
            <div class="toggle-info" id="toggleInfo">1 sty ‚Ä¢ Stary sierp</div>
        </button>
        
        <div id="controlPanel" class="control-panel">
            <h1>üåå Uk≈Çad S≈Çoneczny</h1>
            
            <div class="time-display">
                <div id="currentDate">1 stycznia 2026</div>
                <div><strong id="moonPhase">Stary sierp</strong> ‚Ä¢ <span id="illumination">25%</span></div>
            </div>
            
            <input type="range" id="timeSlider" class="time-slider" min="0" max="1461" value="0" step="0.1">
            
            <div class="section">
                <h3>‚öôÔ∏è Proporcje Uk≈Çadu</h3>
                
                <div style="font-size: 0.75em; color: #64b5f6; margin: 8px 0; opacity: 0.9;">
                    ‚ÑπÔ∏è Rzeczywiste proporcje: 1 AU = 23,481 promieni Ziemi<br>
                    S≈Ço≈Ñce = 109x Ziemia, Ksiƒô≈ºyc = 0.273x Ziemia
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Skala orbit planet:</span>
                        <span class="slider-value" id="planetScaleValue">0.5x</span>
                    </div>
                    <input type="range" id="planetScaleSlider" class="scale-slider" min="0.1" max="1.0" value="0.5" step="0.01">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Skala orbit ksiƒô≈ºyc√≥w:</span>
                        <span class="slider-value" id="moonScaleValue">0.3x</span>
                    </div>
                    <input type="range" id="moonScaleSlider" class="scale-slider" min="0.1" max="0.5" value="0.3" step="0.05">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Skala rozmiar√≥w planet:</span>
                        <span class="slider-value" id="sizeScaleValue">1.0x</span>
                    </div>
                    <input type="range" id="sizeScaleSlider" class="scale-slider" min="1.0" max="4" value="1" step="0.1">
                </div>
                
                <button id="resetScalesButton" class="reset-button">üîÑ Reset do ustawie≈Ñ poczƒÖtkowych</button>
            </div>
            
            <div class="section">
                <h3>üéÆ Animacja</h3>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Prƒôdko≈õƒá:</span>
                        <span class="slider-value"><span id="speedDisplay">1.0x</span> (doba = <span id="dayDuration">3s</span>)</span>
                    </div>
                    <input type="range" id="speedSlider" class="scale-slider" min="0.1" max="5" value="1" step="0.1">
                </div>
                
                <div class="button-row">
                    <button id="playButton" class="control-button">‚ñ∂ Play</button>
                    <button id="resetButton" class="control-button">‚ü≤ Reset</button>
                </div>
                
                <div class="button-row">
                    <button id="cameraToggleButton" class="control-button">üåå Kosmos</button>
                    <button id="resetCameraButton" class="control-button">üì∑ Reset</button>
                    <button id="findMoonButton" class="control-button">üåô Znajd≈∫</button>
                    <button id="debugToggleButton" class="control-button">üêõ Debug</button>
                </div>
            </div>
            
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-label">Rok symulacji</div>
                    <div class="info-value" id="currentYear">2026</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Dzie≈Ñ roku</div>
                    <div class="info-value" id="dayOfYear">1</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Pora roku</div>
                    <div class="info-value" id="season">Zima</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Ziemia-S≈Ço≈Ñce</div>
                    <div class="info-value" id="earthDistance">147 mln km</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Ziemia-Ksiƒô≈ºyc</div>
                    <div class="info-value" id="moonDistance">384 tys km</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Faza Ksiƒô≈ºyca</div>
                    <div class="info-value" id="moonPhaseShort">N√≥w</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Tryb kamery</div>
                    <div class="info-value" id="cameraMode">Ziemia</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Skala orbit</div>
                    <div class="info-value" id="scaleInfo">1.0x</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Rozmiar Ksiƒô≈ºyca</div>
                    <div class="info-value" id="moonVisibility">0.273x Ziemi</div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas3d"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Globalne zmienne
        let scene, camera, renderer;
        let sun, earth, moon;
        let planets = {};
        let planetOrbitGroups = {};
        let moonOrbitGroups = {};
        let earthOrbitGroup, earthTiltGroup, moonOrbitGroup;
        let sunLight;
        let textureLoader;
        let animationRunning = true;
        let lastAnimationTime = 0;
        let animationSpeed = 1;
        let cameraMode = 'earth';

        // Kontrola kamery
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        let cameraDistance = 100; // Zmniejszone z 800 dla nowej skali
        let initialPinchDistance = 0;
        let initialCameraDistance = 0;

        // Skale konfiguracyjne - ustawienia poczƒÖtkowe (zwiƒôkszone dla lepszej widoczno≈õci)
        let planetDistanceScale = 0.5;
        let moonDistanceScale = 0.3;
        let planetSizeScale = 1.0;

        // Dodane zmienne dla naprawienia skakania
        let currentSimulationTime = 0; // Bie≈ºƒÖcy czas symulacji w dniach
        let smoothingFactor = 0.1; // Wsp√≥≈Çczynnik wyg≈Çadzania kamery
        let lastFrameTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;
        let debugMode = false;

        // Poprzednie pozycje dla interpolacji
        let previousEarthPosition = new THREE.Vector3(0, 0, 0);
        let targetEarthPosition = new THREE.Vector3(0, 0, 0);

        // RZECZYWISTE DANE UK≈ÅADU S≈ÅONECZNEGO - PRZESKALOWANE
        const AU_TO_EARTH_RADII = 200; // By≈Ço 23481 - znacznie zmniejszone
        const DISPLAY_AU_SCALE = 1;

        // Warto≈õci domy≈õlne dla reset-u
        const DEFAULT_SETTINGS = {
            planetDistanceScale: 0.5,
            moonDistanceScale: 0.3,
            planetSizeScale: 1.0
        };

        // RZECZYWISTE POZYCJE PLANET NA 1 STYCZNIA 2026 (bazujƒÖc na ephemeris)
        const planetData = {
            mercury: {
                name: 'Merkury',
                realDistanceAU: 0.387,
                realRadiusEarths: 0.383,
                orbitPeriod: 88,
                eccentricity: 0.206,
                startAngle: Math.PI * 1.6, // Superior conjunction 21 stycznia - blisko S≈Ço≈Ñca
                color: 0x8c7853,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/4/4a/Mercury_in_true_color.jpg'
                ]
            },
            venus: {
                name: 'Wenus',
                realDistanceAU: 0.723,
                realRadiusEarths: 0.949,
                orbitPeriod: 225,
                eccentricity: 0.007,
                startAngle: Math.PI * 1.55, // Superior conjunction 6 stycznia - za S≈Ço≈Ñcem
                color: 0xffc649,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/e/e5/Venus-real_color.jpg'
                ]
            },
            earth: {
                name: 'Ziemia',
                realDistanceAU: 1.0,
                realRadiusEarths: 1.0,
                orbitPeriod: 365.25,
                eccentricity: 0.0167,
                startAngle: Math.PI * 1.57, // 1 stycznia blisko peryhelium (4 stycznia)
                color: 0x4fc3f7,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/5/56/Blue_Marble_Next_Generation_%2B_topography_%2B_bathymetry.jpg'
                ]
            },
            mars: {
                name: 'Mars',
                realDistanceAU: 1.524,
                realRadiusEarths: 0.532,
                orbitPeriod: 687,
                eccentricity: 0.094,
                startAngle: Math.PI * 1.6, // Koniunkcja 9 stycznia - blisko S≈Ço≈Ñca
                color: 0xcd5c5c,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/0/02/OSIRIS_Mars_true_color.jpg'
                ]
            },
            jupiter: {
                name: 'Jowisz',
                realDistanceAU: 5.204,
                realRadiusEarths: 11.2,
                orbitPeriod: 4333,
                eccentricity: 0.049,
                startAngle: Math.PI * 0.05, // Opozycja 10 stycznia - po przeciwnej stronie od S≈Ço≈Ñca
                color: 0xd8ca9d,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/e/e1/Jupiter_by_Cassini-Huygens.jpg'
                ]
            },
            saturn: {
                name: 'Saturn',
                realDistanceAU: 9.537,
                realRadiusEarths: 9.4,
                orbitPeriod: 10585,
                eccentricity: 0.052,
                startAngle: Math.PI * 0.8, // Przybli≈ºona pozycja na podstawie danych ksiƒô≈ºycowych
                color: 0xfad5a5,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/c/c7/Saturn_during_Equinox.jpg'
                ]
            },
            uranus: {
                name: 'Uran',
                realDistanceAU: 19.19,
                realRadiusEarths: 4.0,
                orbitPeriod: 30660,
                eccentricity: 0.046,
                startAngle: Math.PI * 0.3, // Przybli≈ºona pozycja
                color: 0x4fd0e3,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/3/3d/Uranus2.jpg'
                ]
            },
            neptune: {
                name: 'Neptun',
                realDistanceAU: 30.07,
                realRadiusEarths: 3.9,
                orbitPeriod: 60225,
                eccentricity: 0.010,
                startAngle: Math.PI * 1.3, // Przybli≈ºona pozycja
                color: 0x4b70dd,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/6/63/Neptune_-_Voyager_2_%2829347980845%29_flatten_crop.jpg'
                ]
            }
        };

        // RZECZYWISTA POZYCJA KSIƒò≈ªYCA NA 1 STYCZNIA 2026
        // Na podstawie ephemeris: Ostatnia kwadra 10 stycznia, wiƒôc 1 stycznia = "stary sierp"
        const moonData = {
            earth: {
                moon: {
                    name: 'Ksiƒô≈ºyc',
                    realDistanceEarthRadii: 60.3,
                    realRadiusEarths: 0.273,
                    orbitPeriod: 29.53,
                    color: 0xe0e0e0,
                    startPhaseAngle: Math.PI * 1.3 // Oko≈Ço 20 dni po nowie = "stary sierp"
                }
            }
        };

        const earthRadius = 1;
        const sunRadius = 5; // By≈Ço 109 - zmniejszone dla lepszej skali
        const earthAxialTilt = -23.5 * (Math.PI / 180);
        const earthEccentricity = 0.0167;
        const moonEccentricity = 0.055;
        const moonOrbitalTilt = 5.1 * (Math.PI / 180);

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(50, 20, 50);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas3d'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            textureLoader = new THREE.TextureLoader();
            
            const ambientLight = new THREE.AmbientLight(0x202040, 0.01);
            scene.add(ambientLight);
            
            createSun();
            createPlanets();
            createStars();
            setupEventListeners();
        }

        function createSun() {
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32);
            const sunMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffeb3b,
                emissive: 0xffaa00
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 0, 0);
            scene.add(sun);
            
            const sunGlowGeometry = new THREE.SphereGeometry(sunRadius * 1.5, 32, 32);
            const sunGlowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00,
                transparent: true,
                opacity: 0.3
            });
            const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
            scene.add(sunGlow);
            
            sunLight = new THREE.PointLight(0xffffff, 2.5, 2000, 2);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 1500;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.bias = -0.0001;
            sunLight.shadow.normalBias = 0.01;
            scene.add(sunLight);
        }

        function createPlanets() {
            Object.keys(planetData).forEach(planetKey => {
                const planetInfo = planetData[planetKey];
                
                const orbitGroup = new THREE.Group();
                scene.add(orbitGroup);
                planetOrbitGroups[planetKey] = orbitGroup;
                
                if (planetKey === 'earth') {
                    earthOrbitGroup = orbitGroup;
                    earthTiltGroup = new THREE.Group();
                    // Usuniƒôto statyczne nachylenie - bƒôdzie dynamicznie obliczane
                    earthOrbitGroup.add(earthTiltGroup);
                    
                    const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
                    const earthMaterial = new THREE.MeshLambertMaterial({ 
                        color: planetInfo.color,
                        emissive: 0x000022
                    });
                    
                    earth = new THREE.Mesh(earthGeometry, earthMaterial);
                    earth.castShadow = true;
                    earth.receiveShadow = true;
                    earthTiltGroup.add(earth);
                    
                    if (planetInfo.textureUrls) {
                        loadTextureWithFallback(earth, planetInfo, planetInfo.textureUrls);
                    }
                    
                    moonOrbitGroup = new THREE.Group();
                    earthTiltGroup.add(moonOrbitGroup);
                    
                    const moonRadius = moonData.earth.moon.realRadiusEarths;
                    const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
                    const moonMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xf0f0f0,
                        emissive: 0x222222
                    });
                    
                    moon = new THREE.Mesh(moonGeometry, moonMaterial);
                    moon.castShadow = true;
                    moon.receiveShadow = true;
                    moonOrbitGroup.add(moon);
                    
                    planets[planetKey] = earth;
                } else {
                    const geometry = new THREE.SphereGeometry(1, 32, 32);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: planetInfo.color,
                        emissive: 0x111111
                    });
                    
                    const planet = new THREE.Mesh(geometry, material);
                    planet.castShadow = true;
                    planet.receiveShadow = true;
                    orbitGroup.add(planet);
                    
                    planets[planetKey] = planet;
                    
                    if (planetInfo.textureUrls) {
                        loadTextureWithFallback(planet, planetInfo, planetInfo.textureUrls);
                    }
                }
            });
            
            createOrbitLines();
        }

        function createOrbitLines() {
            scene.children = scene.children.filter(child => !child.userData.orbitLine);
            
            if (earthTiltGroup) {
                earthTiltGroup.children = earthTiltGroup.children.filter(child => !child.userData.orbitLine);
            }
            
            Object.keys(planetData).forEach(planetKey => {
                const planetInfo = planetData[planetKey];
                const orbitRadius = calculatePlanetOrbitRadius(planetInfo);
                
                const orbitPoints = [];
                for (let i = 0; i <= 128; i++) {
                    const angle = (i / 128) * Math.PI * 2;
                    const distance = orbitRadius * (1 - planetInfo.eccentricity * Math.cos(angle));
                    orbitPoints.push(new THREE.Vector3(
                        Math.cos(angle) * distance,
                        0,
                        Math.sin(angle) * distance
                    ));
                }
                
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                const orbitMaterial = new THREE.LineBasicMaterial({ 
                    color: planetKey === 'earth' ? 0x888888 : 0x444444,
                    transparent: true,
                    opacity: planetKey === 'earth' ? 0.6 : 0.3
                });
                const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                orbitLine.userData.orbitLine = true;
                orbitLine.userData.planet = planetKey;
                scene.add(orbitLine);
            });
            
            const moonOrbitRadius = calculateMoonOrbitRadius(moonData.earth.moon, earthRadius);
            const moonOrbitPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                const distance = moonOrbitRadius * (1 - moonEccentricity * Math.cos(angle));
                
                const x = Math.cos(angle) * distance;
                const y = Math.sin(angle) * distance * Math.sin(moonOrbitalTilt) * 3;
                const z = Math.sin(angle) * distance * Math.cos(moonOrbitalTilt);
                
                moonOrbitPoints.push(new THREE.Vector3(x, y, z));
            }
            
            const moonOrbitGeometry = new THREE.BufferGeometry().setFromPoints(moonOrbitPoints);
            const moonOrbitMaterial = new THREE.LineBasicMaterial({ 
                color: 0xaaaaaa,
                transparent: true,
                opacity: 0.7
            });
            const moonOrbitLine = new THREE.Line(moonOrbitGeometry, moonOrbitMaterial);
            moonOrbitLine.userData.orbitLine = true;
            moonOrbitLine.userData.planet = 'moon';
            
            if (earthTiltGroup) {
                earthTiltGroup.add(moonOrbitLine);
            }
        }

        function createStars() {
            const starDistance = 3000; // Zmniejszone z 15000
            
            // Prawdziwe konstelacje z przybli≈ºonymi pozycjami (rektascensja, deklinacja)
            const constellations = {
                // ZNAKI ZODIAKU
                'Baran': [
                    { ra: 2.12, dec: 23.5, mag: 2.0 }, // Hamal
                    { ra: 2.07, dec: 20.8, mag: 2.6 }, // Sheratan
                    { ra: 1.91, dec: 20.5, mag: 4.4 }  // Mesarthim
                ],
                'Byk': [
                    { ra: 4.6, dec: 16.5, mag: 0.9 },   // Aldebaran
                    { ra: 5.44, dec: 28.6, mag: 3.0 },  // Ain
                    { ra: 3.41, dec: 24.1, mag: 1.7 }   // Alcyone (Plejady)
                ],
                'Bli≈∫niƒôta': [
                    { ra: 7.58, dec: 28.0, mag: 1.6 },  // Castor
                    { ra: 7.76, dec: 28.0, mag: 1.1 }   // Pollux
                ],
                'Rak': [
                    { ra: 8.78, dec: 18.2, mag: 4.3 },  // Acubens
                    { ra: 8.44, dec: 21.5, mag: 3.9 }   // Al Tarf
                ],
                'Lew': [
                    { ra: 10.14, dec: 23.4, mag: 1.4 }, // Regulus
                    { ra: 11.82, dec: 14.6, mag: 2.0 }, // Denebola
                    { ra: 10.33, dec: 16.8, mag: 3.4 }  // Algieba
                ],
                'Panna': [
                    { ra: 13.42, dec: -11.2, mag: 1.0 }, // Spica
                    { ra: 12.93, dec: 3.4, mag: 3.4 },   // Zavijava
                    { ra: 14.85, dec: 1.9, mag: 2.8 }    // Vindemiatrix
                ],
                'Waga': [
                    { ra: 14.85, dec: -16.0, mag: 2.8 }, // Zubeneschamali
                    { ra: 15.28, dec: -9.4, mag: 2.6 }   // Zubenelgenubi
                ],
                'Skorpion': [
                    { ra: 16.49, dec: -26.4, mag: 1.1 }, // Antares
                    { ra: 17.56, dec: -37.1, mag: 1.6 }, // Shaula
                    { ra: 16.84, dec: -34.3, mag: 2.3 }  // Sargas
                ],
                'Strzelec': [
                    { ra: 19.04, dec: -29.9, mag: 1.8 }, // Kaus Australis
                    { ra: 18.96, dec: -26.3, mag: 2.1 }, // Nunki
                    { ra: 19.16, dec: -27.7, mag: 2.8 }  // Kaus Media
                ],
                'Kozioro≈ºec': [
                    { ra: 20.29, dec: -12.5, mag: 3.6 }, // Algedi
                    { ra: 21.37, dec: -16.1, mag: 2.9 }  // Deneb Algedi
                ],
                'Wodnik': [
                    { ra: 22.10, dec: -0.3, mag: 2.9 },  // Sadalsuud
                    { ra: 21.53, dec: -5.6, mag: 3.0 }   // Sadalmelik
                ],
                'Ryby': [
                    { ra: 1.49, dec: 15.3, mag: 3.6 },   // Alrescha
                    { ra: 23.67, dec: 5.6, mag: 4.5 }    // Fum al Samakah
                ],
                
                // KONSTELACJE OKO≈ÅOBIEGUNOWE
                'Wielka Nied≈∫wiedzica': [
                    { ra: 11.06, dec: 61.8, mag: 1.8 }, // Dubhe
                    { ra: 11.03, dec: 56.4, mag: 2.3 }, // Merak
                    { ra: 12.26, dec: 57.0, mag: 2.3 }, // Phecda
                    { ra: 12.26, dec: 57.0, mag: 2.3 }, // Megrez
                    { ra: 12.90, dec: 55.9, mag: 1.8 }, // Alioth
                    { ra: 13.42, dec: 49.3, mag: 2.2 }, // Mizar
                    { ra: 13.79, dec: 49.3, mag: 1.9 }  // Alkaid
                ],
                'Ma≈Ça Nied≈∫wiedzica': [
                    { ra: 2.53, dec: 89.3, mag: 2.0 },  // Polaris (Gwiazda Polarna)
                    { ra: 15.35, dec: 71.8, mag: 4.4 }, // Yildun
                    { ra: 16.29, dec: 75.8, mag: 4.2 }  // Pherkad
                ],
                'Kasjopeja': [
                    { ra: 0.95, dec: 56.5, mag: 2.2 },  // Schedar
                    { ra: 0.15, dec: 59.1, mag: 2.3 },  // Caph
                    { ra: 1.43, dec: 60.2, mag: 2.5 },  // Gamma Cas
                    { ra: 1.90, dec: 63.7, mag: 3.4 },  // Ruchbah
                    { ra: 2.29, dec: 67.1, mag: 3.4 }   // Segin
                ],
                'Orion': [
                    { ra: 5.92, dec: 7.4, mag: 0.1 },   // Rigel
                    { ra: 5.59, dec: 7.4, mag: 0.4 },   // Betelgeuse
                    { ra: 5.68, dec: -1.2, mag: 1.7 },  // Alnilam
                    { ra: 5.60, dec: -1.9, mag: 1.8 },  // Alnitak
                    { ra: 5.53, dec: -0.3, mag: 2.2 }   // Mintaka
                ],
                '≈Åabƒôd≈∫': [
                    { ra: 20.37, dec: 45.3, mag: 1.3 }, // Deneb
                    { ra: 19.51, dec: 27.9, mag: 2.2 }, // Sadr
                    { ra: 19.75, dec: 33.9, mag: 3.9 }  // Gienah
                ]
            };
            
            // Usu≈Ñ stare gwiazdy
            scene.children = scene.children.filter(child => !child.userData.isStars);
            
            // Stw√≥rz gwiazdy z konstelacji
            Object.keys(constellations).forEach(constName => {
                const stars = constellations[constName];
                
                stars.forEach(star => {
                    // Konwersja wsp√≥≈Çrzƒôdnych r√≥wnikowych na kartezja≈Ñskie
                    const ra = star.ra * (Math.PI / 12); // Rektascensja (godziny -> radiany)
                    const dec = star.dec * (Math.PI / 180); // Deklinacja (stopnie -> radiany)
                    
                    const x = starDistance * Math.cos(dec) * Math.cos(ra);
                    const y = starDistance * Math.sin(dec);
                    const z = starDistance * Math.cos(dec) * Math.sin(ra);
                    
                    // Rozmiar gwiazdy zale≈ºny od jasno≈õci (magnitude)
                    let starSize = Math.max(0.5, 4.0 - star.mag);
                    if (star.mag < 1.5) starSize *= 1.5; // Ja≈õniejsze gwiazdy wiƒôksze
                    
                    const starGeometry = new THREE.SphereGeometry(starSize, 8, 8);
                    const starMaterial = new THREE.MeshBasicMaterial({ 
                        color: getStarColor(star.mag),
                        emissive: getStarColor(star.mag),
                        emissiveIntensity: 0.3
                    });
                    
                    const starMesh = new THREE.Mesh(starGeometry, starMaterial);
                    starMesh.position.set(x, y, z);
                    starMesh.userData.isStars = true;
                    starMesh.userData.constellation = constName;
                    starMesh.userData.magnitude = star.mag;
                    
                    scene.add(starMesh);
                });
            });
            
            // Dodaj dodatkowe gwiazdy t≈Ça dla pe≈Çnego nieba
            const backgroundStarGeometry = new THREE.BufferGeometry();
            const backgroundStarCount = 2000;
            const positions = new Float32Array(backgroundStarCount * 3);
            
            for (let i = 0; i < backgroundStarCount * 3; i += 3) {
                // R√≥wnomierne rozmieszczenie na sferze
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                
                positions[i] = starDistance * 0.9 * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = starDistance * 0.9 * Math.cos(phi);
                positions[i + 2] = starDistance * 0.9 * Math.sin(phi) * Math.sin(theta);
            }
            
            backgroundStarGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const backgroundStarMaterial = new THREE.PointsMaterial({ 
                color: 0xaaaaff,
                size: 1.0,
                sizeAttenuation: false
            });
            const backgroundStars = new THREE.Points(backgroundStarGeometry, backgroundStarMaterial);
            backgroundStars.userData.isStars = true;
            scene.add(backgroundStars);
        }
        
        function getStarColor(magnitude) {
            // Kolory gwiazd zale≈ºne od jasno≈õci
            if (magnitude < 1.0) return 0xffffaa; // Bardzo jasne - bia≈Ço≈º√≥≈Çte
            if (magnitude < 2.0) return 0xffffff; // Jasne - bia≈Çe  
            if (magnitude < 3.0) return 0xaaffff; // ≈örednie - bia≈Çoniebieskie
            return 0x8888ff; // S≈Çabe - niebieskie
        }

        function loadTextureWithFallback(planet, planetInfo, urls, index = 0) {
            if (!urls || index >= urls.length) {
                console.log(`‚ùå Wszystkie tekstury ${planetInfo.name} nieudane - u≈ºywam koloru`);
                return;
            }
            
            textureLoader.load(
                urls[index],
                function(texture) {
                    console.log(`‚úÖ Tekstura ${planetInfo.name} za≈Çadowana`);
                    planet.material.map = texture;
                    planet.material.color.setHex(0xffffff);
                    planet.material.needsUpdate = true;
                },
                undefined,
                function(error) {
                    console.log(`‚ùå B≈ÇƒÖd tekstury ${planetInfo.name}, pr√≥bujƒô nastƒôpnƒÖ...`);
                    loadTextureWithFallback(planet, planetInfo, urls, index + 1);
                }
            );
        }

        function calculatePlanetOrbitRadius(planetInfo) {
            return planetInfo.realDistanceAU * AU_TO_EARTH_RADII * earthRadius * planetDistanceScale;
        }

        function calculateMoonOrbitRadius(moonInfo, planetRadius) {
            return moonInfo.realDistanceEarthRadii * planetRadius * moonDistanceScale;
        }

        function calculatePlanetRadius(planetInfo) {
            return planetInfo.realRadiusEarths * earthRadius * planetSizeScale;
        }

        function updatePlanetSizes() {
            Object.keys(planetData).forEach(planetKey => {
                const planetInfo = planetData[planetKey];
                const planet = planets[planetKey];
                if (planet) {
                    const newRadius = calculatePlanetRadius(planetInfo);
                    planet.scale.setScalar(newRadius);
                }
            });
            
            if (moon) {
                const moonRadius = moonData.earth.moon.realRadiusEarths * earthRadius * planetSizeScale;
                moon.scale.setScalar(moonRadius);
            }
        }

        // KLUCZOWA FUNKCJA - Naprawiona aktualizacja pozycji
        function updatePositions(totalDays) {
            // Zapisz poprzedniƒÖ pozycjƒô Ziemi dla interpolacji
            if (earthOrbitGroup) {
                previousEarthPosition.copy(earthOrbitGroup.position);
            }

            Object.keys(planetData).forEach(planetKey => {
                const planetInfo = planetData[planetKey];
                const orbitRadius = calculatePlanetOrbitRadius(planetInfo);
                
                if (planetKey === 'earth') {
                    const earthOrbitAngle = (totalDays / planetInfo.orbitPeriod) * 2 * Math.PI + planetInfo.startAngle;
                    const earthDistance = orbitRadius * (1 - earthEccentricity * Math.cos(earthOrbitAngle));
                    
                    const earthX = Math.cos(earthOrbitAngle) * earthDistance;
                    const earthZ = Math.sin(earthOrbitAngle) * earthDistance;
                    
                    // Ustaw docelowƒÖ pozycjƒô Ziemi
                    targetEarthPosition.set(earthX, 0, earthZ);
                    earthOrbitGroup.position.copy(targetEarthPosition);
                    
                    // NAPRAWIONE nachylenie osi - zsynchronizowane z pozycjƒÖ orbitalnƒÖ
                    // W czerwcu (dzie≈Ñ ~172) biegun p√≥≈Çnocny nachylony toward s≈Ço≈Ñca (lato p√≥≈Çnocne)
                    // W grudniu (dzie≈Ñ ~355/0) biegun p√≥≈Çnocny nachylony away od s≈Ço≈Ñca (zima p√≥≈Çnocna)
                    const axialTiltAngle = earthOrbitAngle + Math.PI; // +180¬∞ offset dla prawid≈Çowej orientacji
                    earthTiltGroup.rotation.z = earthAxialTilt * Math.cos(axialTiltAngle);
                    
                    const dayProgress = totalDays % 1;
                    earth.rotation.y = dayProgress * 2 * Math.PI;
                    
                    const moonOrbitRadius = calculateMoonOrbitRadius(moonData.earth.moon, earthRadius);
                    // RZECZYWISTA pozycja Ksiƒô≈ºyca z prawid≈ÇowƒÖ fazƒÖ startowƒÖ na 1 stycznia 2026
                    const moonOrbitAngle = (totalDays / moonData.earth.moon.orbitPeriod) * 2 * Math.PI + (moonData.earth.moon.startPhaseAngle || 0);
                    const moonDistance = moonOrbitRadius * (1 - moonEccentricity * Math.cos(moonOrbitAngle));
                    
                    const moonX = Math.cos(moonOrbitAngle) * moonDistance;
                    const moonY = Math.sin(moonOrbitAngle) * moonDistance * Math.sin(moonOrbitalTilt) * 3;
                    const moonZ = Math.sin(moonOrbitAngle) * moonDistance * Math.cos(moonOrbitalTilt);
                    
                    moon.position.set(moonX, moonY, moonZ);
                    moon.rotation.y = moonOrbitAngle;
                } else {
                    const orbitAngle = (totalDays / planetInfo.orbitPeriod) * 2 * Math.PI + planetInfo.startAngle;
                    const distance = orbitRadius * (1 - 0.01 * Math.cos(orbitAngle));
                    
                    const x = Math.cos(orbitAngle) * distance;
                    const z = Math.sin(orbitAngle) * distance;
                    
                    if (planets[planetKey]) {
                        planets[planetKey].position.set(x, 0, z);
                        
                        const dayProgress = totalDays % 1;
                        planets[planetKey].rotation.y = dayProgress * 2 * Math.PI;
                    }
                }
            });
        }

        function getMoonPhase(totalDays) {
            const earthOrbitAngle = (totalDays / planetData.earth.orbitPeriod) * 2 * Math.PI + planetData.earth.startAngle;
            // RZECZYWISTA pozycja Ksiƒô≈ºyca z fazƒÖ startowƒÖ
            const moonOrbitAngle = (totalDays / moonData.earth.moon.orbitPeriod) * 2 * Math.PI + (moonData.earth.moon.startPhaseAngle || 0);
            
            const earthOrbitRadius = calculatePlanetOrbitRadius(planetData.earth);
            const earthDistance = earthOrbitRadius * (1 - earthEccentricity * Math.cos(earthOrbitAngle));
            const earthX = Math.cos(earthOrbitAngle) * earthDistance;
            const earthZ = Math.sin(earthOrbitAngle) * earthDistance;
            
            const moonOrbitRadius = calculateMoonOrbitRadius(moonData.earth.moon, earthRadius);
            const moonDistance = moonOrbitRadius * (1 - moonEccentricity * Math.cos(moonOrbitAngle));
            const moonLocalX = Math.cos(moonOrbitAngle) * moonDistance;
            const moonLocalZ = Math.sin(moonOrbitAngle) * moonDistance * Math.cos(moonOrbitalTilt);
            
            const sunToEarth = { x: earthX, z: earthZ };
            const earthToMoon = { x: moonLocalX, z: moonLocalZ };
            
            const dotProduct = sunToEarth.x * earthToMoon.x + sunToEarth.z * earthToMoon.z;
            const sunEarthMag = Math.sqrt(sunToEarth.x * sunToEarth.x + sunToEarth.z * sunToEarth.z);
            const earthMoonMag = Math.sqrt(earthToMoon.x * earthToMoon.x + earthToMoon.z * earthToMoon.z);
            
            const cosAngle = dotProduct / (sunEarthMag * earthMoonMag);
            const phaseAngle = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
            
            if (phaseAngle < 22.5 || phaseAngle >= 337.5) return { name: 'Pe≈Çnia', illumination: 100 };
            if (phaseAngle < 67.5) return { name: 'UbywajƒÖcy garb', illumination: 75 };
            if (phaseAngle < 112.5) return { name: 'Ostatnia kwadra', illumination: 50 };
            if (phaseAngle < 157.5) return { name: 'Stary sierp', illumination: 25 };
            if (phaseAngle < 202.5) return { name: 'N√≥w', illumination: 0 };
            if (phaseAngle < 247.5) return { name: 'M≈Çody sierp', illumination: 25 };
            if (phaseAngle < 292.5) return { name: 'Pierwsza kwadra', illumination: 50 };
            return { name: 'PrzybywajƒÖcy garb', illumination: 75 };
        }

        function resetScales() {
            planetDistanceScale = DEFAULT_SETTINGS.planetDistanceScale;
            moonDistanceScale = DEFAULT_SETTINGS.moonDistanceScale;
            planetSizeScale = DEFAULT_SETTINGS.planetSizeScale;
            
            document.getElementById('planetScaleSlider').value = planetDistanceScale;
            document.getElementById('moonScaleSlider').value = moonDistanceScale;
            document.getElementById('sizeScaleSlider').value = planetSizeScale;
            
            updateScaleDisplays();
            updatePlanetSizes();
            createOrbitLines();
            
            const currentTime = parseFloat(document.getElementById('timeSlider').value);
            updatePositions(currentTime);
            updateUIOnly(currentTime);
            
            if (cameraMode === 'space') {
                const earthOrbitRadius = calculatePlanetOrbitRadius(planetData.earth);
                cameraDistance = Math.max(200, earthOrbitRadius * 2);
            } else {
                cameraDistance = 25;
            }
        }

        function updateScaleDisplays() {
            document.getElementById('planetScaleValue').textContent = planetDistanceScale.toFixed(3) + 'x';
            document.getElementById('moonScaleValue').textContent = moonDistanceScale.toFixed(1) + 'x';
            document.getElementById('sizeScaleValue').textContent = planetSizeScale.toFixed(1) + 'x';
            document.getElementById('speedDisplay').textContent = animationSpeed.toFixed(1) + 'x';
            document.getElementById('dayDuration').textContent = (3 / animationSpeed).toFixed(1) + 's';
            
            const earthOrbitRadius = calculatePlanetOrbitRadius(planetData.earth);
            const distanceFromSurface = earthOrbitRadius - sunRadius;
            document.getElementById('scaleInfo').textContent = `${planetDistanceScale.toFixed(2)}x (Ziemia: ${distanceFromSurface.toFixed(0)} j. od powierzchni)`;
        }

        function setupEventListeners() {
            const canvas = document.getElementById('canvas3d');
            
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);
            
            document.getElementById('timeSlider').addEventListener('input', function(e) {
                const totalDays = parseFloat(e.target.value);
                currentSimulationTime = totalDays; // Zaktualizuj bie≈ºƒÖcy czas
                updatePositions(totalDays);
                updateUIOnly(totalDays);
            });
            
            document.getElementById('speedSlider').addEventListener('input', function(e) {
                animationSpeed = parseFloat(e.target.value);
                updateScaleDisplays();
            });
            
            document.getElementById('planetScaleSlider').addEventListener('input', function(e) {
                planetDistanceScale = parseFloat(e.target.value);
                updateScaleDisplays();
                updatePlanetSizes();
                createOrbitLines();
                const currentTime = parseFloat(document.getElementById('timeSlider').value);
                updatePositions(currentTime);
                updateUIOnly(currentTime);
            });
            
            document.getElementById('moonScaleSlider').addEventListener('input', function(e) {
                moonDistanceScale = parseFloat(e.target.value);
                updateScaleDisplays();
                const currentTime = parseFloat(document.getElementById('timeSlider').value);
                updatePositions(currentTime);
            });
            
            document.getElementById('sizeScaleSlider').addEventListener('input', function(e) {
                planetSizeScale = parseFloat(e.target.value);
                updateScaleDisplays();
                updatePlanetSizes();
            });
            
            document.getElementById('resetScalesButton').addEventListener('click', resetScales);
            
            document.getElementById('playButton').addEventListener('click', toggleAnimation);
            document.getElementById('resetButton').addEventListener('click', resetAnimation);
            document.getElementById('resetCameraButton').addEventListener('click', resetCamera);
            document.getElementById('cameraToggleButton').addEventListener('click', toggleCameraMode);
            document.getElementById('findMoonButton').addEventListener('click', findMoon);
            document.getElementById('debugToggleButton').addEventListener('click', toggleDebug);
            
            document.getElementById('mobileToggle').addEventListener('click', function() {
                const controlPanel = document.getElementById('controlPanel');
                const isCollapsed = controlPanel.classList.contains('mobile-collapsed');
                if (isCollapsed) {
                    controlPanel.classList.remove('mobile-collapsed');
                    this.innerHTML = '<div>‚úï Zamknij</div><div class="toggle-info" id="toggleInfo"></div>';
                } else {
                    controlPanel.classList.add('mobile-collapsed');
                    this.innerHTML = '<div>‚öôÔ∏è Options</div><div class="toggle-info" id="toggleInfo"></div>';
                }
                updateToggleInfo();
            });
            
            window.addEventListener('resize', onWindowResize);
            
            initializeMobileUI();
        }

        function initializeMobileUI() {
            const controlPanel = document.getElementById('controlPanel');
            const mobileToggle = document.getElementById('mobileToggle');
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                controlPanel.classList.add('mobile-collapsed');
                mobileToggle.style.display = 'block';
            } else {
                controlPanel.classList.remove('mobile-collapsed');
                mobileToggle.style.display = 'none';
            }
            updateToggleInfo();
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            targetRotationY += deltaX * 0.01;
            targetRotationX += deltaY * 0.01;
            targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onMouseWheel(event) {
            cameraDistance += event.deltaY * 0.1;
            if (cameraMode === 'earth') {
                cameraDistance = Math.max(8, Math.min(100, cameraDistance));
            } else {
                const earthOrbitRadius = calculatePlanetOrbitRadius(planetData.earth);
                const maxDistance = Math.max(1000, earthOrbitRadius * 5);
                cameraDistance = Math.max(100, Math.min(maxDistance, cameraDistance));
            }
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                isMouseDown = true;
            } else if (event.touches.length === 2) {
                initialPinchDistance = getPinchDistance(event.touches);
                initialCameraDistance = cameraDistance;
                isMouseDown = false;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - touchStartX;
                const deltaY = event.touches[0].clientY - touchStartY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                const currentPinchDistance = getPinchDistance(event.touches);
                const pinchRatio = currentPinchDistance / initialPinchDistance;
                cameraDistance = initialCameraDistance / pinchRatio;
                
                if (cameraMode === 'earth') {
                    cameraDistance = Math.max(8, Math.min(100, cameraDistance));
                } else {
                    const earthOrbitRadius = calculatePlanetOrbitRadius(planetData.earth);
                    const maxDistance = Math.max(1000, earthOrbitRadius * 5);
                    cameraDistance = Math.max(100, Math.min(maxDistance, cameraDistance));
                }
            }
        }

        function onTouchEnd(event) {
            if (event.touches.length === 0) {
                isMouseDown = false;
            }
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        let touchStartX = 0, touchStartY = 0;

        // NAPRAWIONA funkcja updateCameraPosition - z p≈ÇynnƒÖ interpolacjƒÖ
        function updateCameraPosition() {
            // P≈Çynna interpolacja rotacji
            currentRotationX += (targetRotationX - currentRotationX) * smoothingFactor;
            currentRotationY += (targetRotationY - currentRotationY) * smoothingFactor;
            
            if (cameraMode === 'earth') {
                const earthPos = earthOrbitGroup.position;
                
                const x = earthPos.x + Math.cos(currentRotationX) * Math.sin(currentRotationY) * cameraDistance;
                const y = earthPos.y + Math.sin(currentRotationX) * cameraDistance;
                const z = earthPos.z + Math.cos(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
                
                camera.position.set(x, y, z);
                camera.lookAt(earthPos.x, earthPos.y, earthPos.z);
            } else {
                const x = Math.cos(currentRotationX) * Math.sin(currentRotationY) * cameraDistance;
                const y = Math.sin(currentRotationX) * cameraDistance;
                const z = Math.cos(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
                
                camera.position.set(x, y, z);
                camera.lookAt(0, 0, 0);
            }
        }

        function resetCamera() {
            targetRotationX = 0;
            targetRotationY = 0;
            if (cameraMode === 'earth') {
                cameraDistance = 25;
            } else {
                const earthOrbitRadius = calculatePlanetOrbitRadius(planetData.earth);
                cameraDistance = Math.max(200, earthOrbitRadius * 2);
            }
        }

        function toggleCameraMode() {
            if (cameraMode === 'earth') {
                cameraMode = 'space';
                const earthOrbitRadius = calculatePlanetOrbitRadius(planetData.earth);
                cameraDistance = Math.max(200, earthOrbitRadius * 2);
                targetRotationX = 0.3;
                targetRotationY = 0;
            } else {
                cameraMode = 'earth';
                cameraDistance = 25;
                targetRotationX = 0;
                targetRotationY = 0;
            }
            updateCameraModeUI();
        }

        function findMoon() {
            cameraMode = 'earth';
            
            const moonOrbitRadius = calculateMoonOrbitRadius(moonData.earth.moon, earthRadius);
            cameraDistance = Math.max(15, moonOrbitRadius * 1.5);
            
            targetRotationX = 0;
            targetRotationY = 0;
            
            updateCameraModeUI();
        }

        function updateCameraModeUI() {
            const button = document.getElementById('cameraToggleButton');
            const modeDisplay = document.getElementById('cameraMode');
            
            if (button) {
                button.innerHTML = cameraMode === 'earth' ? 'üåå Kosmos' : 'üåç Ziemia';
            }
            if (modeDisplay) {
                modeDisplay.textContent = cameraMode === 'earth' ? 'Ziemia' : 'Kosmos';
            }
        }

        function toggleAnimation() {
            const playButton = document.getElementById('playButton');
            
            if (!animationRunning) {
                animationRunning = true;
                playButton.textContent = '‚è∏ Pauza';
                lastAnimationTime = performance.now();
            } else {
                animationRunning = false;
                playButton.textContent = '‚ñ∂ Play';
            }
        }

        function resetAnimation() {
            const startingDay = 309;

            animationRunning = false;
            document.getElementById('playButton').textContent = '‚ñ∂ Play';
            document.getElementById('timeSlider').value = startingDay;
            document.getElementById('speedSlider').value = 1;
            animationSpeed = 1;
            currentSimulationTime = startingDay;
            updatePositions(startingDay);
            updateUIOnly(startingDay);
            updateScaleDisplays();
        }

        function toggleDebug() {
            debugMode = !debugMode;
            const debugInfo = document.getElementById('debugInfo');
            debugInfo.style.display = debugMode ? 'block' : 'none';
        }

        function updateDebugInfo() {
            if (!debugMode) return;
            
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - lastFpsTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastFpsTime));
                document.getElementById('fpsDisplay').textContent = fps;
                frameCount = 0;
                lastFpsTime = currentTime;
            }
            
            if (earthOrbitGroup) {
                const pos = earthOrbitGroup.position;
                document.getElementById('earthPosDisplay').textContent = 
                    `(${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)})`;
            }
            
            const camPos = camera.position;
            document.getElementById('cameraPosDisplay').textContent = 
                `(${camPos.x.toFixed(0)}, ${camPos.y.toFixed(0)}, ${camPos.z.toFixed(0)})`;
        }

        function getSeason(totalDays) {
            // Oblicz pozycjƒô orbitalnƒÖ Ziemi
            const earthOrbitAngle = (totalDays / planetData.earth.orbitPeriod) * 2 * Math.PI + planetData.earth.startAngle;
            
            // Przelicz kƒÖt orbitalny na pory roku (dla p√≥≈Çkuli p√≥≈Çnocnej)
            // 0¬∞ = przesilenie zimowe (21 grudnia)
            // 90¬∞ = r√≥wnonoc wiosenna (21 marca)  
            // 180¬∞ = przesilenie letnie (21 czerwca)
            // 270¬∞ = r√≥wnonoc jesienna (21 wrze≈õnia)
            
            let seasonAngle = (earthOrbitAngle + Math.PI) % (2 * Math.PI); // Normalizuj do 0-2œÄ
            let seasonDegrees = (seasonAngle * 180 / Math.PI) % 360;
            
            if (seasonDegrees >= 315 || seasonDegrees < 45) return 'Zima';      // Grudzie≈Ñ-Luty
            if (seasonDegrees >= 45 && seasonDegrees < 135) return 'Wiosna';    // Marzec-Maj  
            if (seasonDegrees >= 135 && seasonDegrees < 225) return 'Lato';     // Czerwiec-Sierpie≈Ñ
            return 'Jesie≈Ñ';                                                     // Wrzesie≈Ñ-Listopad
        }

        function updateUIOnly(totalDays) {
            const phase = getMoonPhase(totalDays);
            
            // RZECZYWISTE LATA 2026-2030
            const currentYear = Math.floor(totalDays / 365.25) + 2026;
            const dayOfYear = totalDays % 365.25;
            
            const date = new Date(currentYear, 0, Math.floor(dayOfYear) + 1);
            const dateStr = date.toLocaleDateString('pl-PL', { day: 'numeric', month: 'long', year: 'numeric' });
            
            document.getElementById('currentDate').textContent = dateStr;
            document.getElementById('moonPhase').textContent = phase.name;
            document.getElementById('illumination').textContent = phase.illumination + '%';
            document.getElementById('currentYear').textContent = currentYear;
            document.getElementById('dayOfYear').textContent = Math.floor(dayOfYear) + 1;
            document.getElementById('season').textContent = getSeason(totalDays);
            document.getElementById('moonPhaseShort').textContent = phase.name;
            
            const earthOrbitAngle = (totalDays / planetData.earth.orbitPeriod) * 2 * Math.PI + planetData.earth.startAngle;
            const moonOrbitAngle = (totalDays / moonData.earth.moon.orbitPeriod) * 2 * Math.PI + (moonData.earth.moon.startPhaseAngle || 0);
            
            const earthDistanceAU = planetData.earth.realDistanceAU * (1 - planetData.earth.eccentricity * Math.cos(earthOrbitAngle));
            const earthDistanceKm = Math.round(earthDistanceAU * 149.6);
            
            const moonDistanceEarthRadii = moonData.earth.moon.realDistanceEarthRadii * (1 - moonEccentricity * Math.cos(moonOrbitAngle));
            const moonDistanceKm = Math.round(moonDistanceEarthRadii * 6.371);
            
            document.getElementById('earthDistance').textContent = earthDistanceKm + ' mln km';
            document.getElementById('moonDistance').textContent = moonDistanceKm + ' tys km';
            
            const moonSize = moonData.earth.moon.realRadiusEarths * earthRadius * planetSizeScale;
            document.getElementById('moonVisibility').textContent = `${moonSize.toFixed(3)}x Ziemi`;
            
            updateToggleInfo();
        }

        function updateToggleInfo() {
            const toggleInfo = document.getElementById('toggleInfo');
            if (toggleInfo) {
                const totalDays = parseFloat(document.getElementById('timeSlider').value);
                const phase = getMoonPhase(totalDays);
                const currentYear = Math.floor(totalDays / 365.25) + 2026;
                const dayOfYear = totalDays % 365.25;
                const date = new Date(currentYear, 0, Math.floor(dayOfYear) + 1);
                const shortDate = date.toLocaleDateString('pl-PL', { day: 'numeric', month: 'short', year: '2-digit' });
                const season = getSeason(totalDays);
                toggleInfo.textContent = shortDate + ' ‚Ä¢ ' + season + ' ‚Ä¢ ' + phase.name;
            }
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            const controlPanel = document.getElementById('controlPanel');
            const mobileToggle = document.getElementById('mobileToggle');
            const isMobile = width <= 768;
            
            if (isMobile) {
                mobileToggle.style.display = 'block';
            } else {
                mobileToggle.style.display = 'none';
                controlPanel.classList.remove('mobile-collapsed');
            }
        }

        // NAPRAWIONA funkcja animate - bez przeskok√≥w
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            
            updateCameraPosition();
            updateDebugInfo();
            
            // Animacja ≈õwiecenia S≈Ço≈Ñca
            if (sun && sun.material && sun.material.emissive) {
                const time = currentTime * 0.001;
                const intensity = 0.8 + Math.sin(time) * 0.2;
                sun.material.emissive.setRGB(1.0 * intensity, 0.5 * intensity, 0.0);
            }
            
            // CIƒÑG≈ÅA animacja czasowa bez przeskok√≥w
            if (animationRunning) {
                const deltaTime = currentTime - lastAnimationTime;
                const dayDurationMs = 3000 / animationSpeed; // czas trwania jednego dnia w ms
                
                // CiƒÖg≈Çe dodawanie czasu bez skok√≥w
                const dayIncrement = deltaTime / dayDurationMs;
                currentSimulationTime += dayIncrement;
                
                // Resetuj do 0 po przekroczeniu maksymalnego czasu (4 lata = 1461 dni)
                if (currentSimulationTime > 1461) {
                    currentSimulationTime = 0;
                }
                
                // Aktualizuj slider co ka≈ºde 100ms dla wydajno≈õci
                const now = performance.now();
                if (!window.lastSliderUpdate || now - window.lastSliderUpdate > 100) {
                    document.getElementById('timeSlider').value = currentSimulationTime;
                    updateUIOnly(currentSimulationTime);
                    window.lastSliderUpdate = now;
                }
                
                // ZAWSZE p≈Çynna aktualizacja pozycji
                updatePositions(currentSimulationTime);
                lastAnimationTime = currentTime;
            }
            
            renderer.render(scene, camera);
        }

        // Inicjalizacja
        init();
        currentSimulationTime = 0;
        updatePositions(0);
        updateUIOnly(0);
        updateCameraModeUI();
        updateScaleDisplays();

        lastAnimationTime = performance.now();
        document.getElementById('playButton').textContent = '‚è∏ Pauza';

        animate();
        resetAnimation();
    </script>
</body>
</html>