<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Uk≈Çad S≈Çoneczny - 30 Lat Symulacji Zaƒámie≈Ñ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            height: 100dvh;
        }
        
        #canvas3d {
            display: block;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
        }
        
        .ui-overlay {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 100;
            pointer-events: none;
            max-width: 320px;
        }
        
        .mobile-toggle {
            display: none;
            background: rgba(0,0,0,0.9);
            border: 2px solid rgba(100,181,246,0.6);
            border-radius: 25px;
            padding: 10px 16px;
            color: white;
            font-size: 0.85em;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            text-align: center;
            min-width: 140px;
            font-weight: bold;
        }
        
        .mobile-toggle:hover {
            background: rgba(0,0,0,0.95);
            border-color: rgba(100,181,246,0.8);
            transform: translateY(-1px);
        }
        
        .toggle-info {
            font-size: 0.75em;
            color: #64b5f6;
            margin-top: 2px;
        }
        
        .control-panel {
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 18px;
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            min-width: 280px;
            transition: all 0.3s ease;
        }
        
        .control-panel.mobile-collapsed {
            display: none;
        }
        
        h1 {
            font-size: 1.4em;
            margin: 0 0 5px 0;
            color: #64b5f6;
        }
        
        .subtitle {
            font-size: 0.85em;
            margin: 0 0 15px 0;
            opacity: 0.8;
            line-height: 1.3;
        }
        
        .time-display {
            text-align: center;
            margin-bottom: 12px;
            font-size: 1em;
            font-weight: bold;
            color: #ffffff;
            background: rgba(100,181,246,0.2);
            padding: 8px;
            border-radius: 8px;
        }
        
        .time-slider {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            margin: 12px 0;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #64b5f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(100,181,246,0.4);
        }
        
        .time-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #64b5f6;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .button-row {
            display: flex;
            gap: 6px;
            margin: 12px 0;
            flex-wrap: wrap;
        }
        
        .control-button {
            background: #64b5f6;
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 20px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            flex: 1;
            min-width: 60px;
        }
        
        .control-button:hover {
            background: #42a5f5;
            transform: translateY(-1px);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 12px;
        }
        
        @media (max-width: 768px) {
            .info-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
        }
        
        .info-card {
            background: rgba(255,255,255,0.08);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .info-label {
            font-size: 0.75em;
            opacity: 0.8;
            margin-bottom: 3px;
            line-height: 1.2;
        }
        
        .info-value {
            font-size: 0.9em;
            font-weight: bold;
            color: #64b5f6;
        }
        
        /* Na desktop zawsze pokazuj panel */
        @media (min-width: 769px) {
            .mobile-toggle {
                display: none !important;
            }
            
            .control-panel {
                display: block !important;
            }
        }
        
        @media (max-width: 768px) {
            .ui-overlay {
                top: 10px;
                left: 10px;
                max-width: calc(100vw - 20px);
            }
            
            .mobile-toggle {
                display: block !important;
            }
            
            .control-panel {
                padding: 15px;
                margin-top: 10px;
                min-width: auto;
                width: 100%;
                max-width: calc(100vw - 20px);
                max-height: 70vh;
                overflow-y: auto;
            }
            
            .control-panel.mobile-collapsed {
                display: none !important;
            }
            
            h1 {
                font-size: 1.1em;
            }
            
            .subtitle {
                font-size: 0.8em;
                margin-bottom: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .ui-overlay {
                top: 5px;
                left: 5px;
            }
            
            .control-panel {
                padding: 12px;
            }
            
            .control-button {
                padding: 6px 8px;
                font-size: 0.75em;
                min-width: 50px;
            }
            
            .info-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
            
            .info-card {
                padding: 6px;
            }
            
            .info-label {
                font-size: 0.7em;
            }
            
            .info-value {
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="ui-overlay">
        <button id="mobileToggle" class="mobile-toggle">
            <div>‚öôÔ∏è Options</div>
            <div class="toggle-info" id="toggleInfo">1 sty ‚Ä¢ N√≥w</div>
        </button>
        
        <div id="controlPanel" class="control-panel">
            <h1>üåç Uk≈Çad S≈Çoneczny 30 Lat</h1>
            <p class="subtitle">
                PrzeciƒÖgnij: obracaj ‚Ä¢ Scroll/Pinch: zoom<br>
                <small><span id="cameraModeText">Widok z Ziemi</span> ‚Ä¢ 30 lat symulacji! Znajd≈∫ prawdziwe zaƒámienia s≈Ço≈Ñca</small>
            </p>
            
            <div class="time-display">
                <div id="currentDate">1 stycznia 2025</div>
                <div><strong id="moonPhase">N√≥w</strong> ‚Ä¢ <span id="illumination">0%</span></div>
            </div>
            
            <input type="range" id="timeSlider" class="time-slider" min="0" max="10950" value="0" step="0.1">
            
            <div style="margin: 10px 0; text-align: center;">
                <label style="font-size: 0.8em; opacity: 0.8;">Prƒôdko≈õƒá animacji:</label>
                <input type="range" id="speedSlider" class="time-slider" min="0.1" max="3" value="1" step="0.1" style="margin: 5px 0;">
                <div style="font-size: 0.75em; opacity: 0.7;">
                    <span id="speedDisplay">1.0x</span> (doba = <span id="dayDuration">3s</span>)
                </div>
            </div>
            
            <div style="margin: 12px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                <label style="font-size: 0.8em; opacity: 0.8; display: block; margin-bottom: 5px;">Tekstura Ksiƒô≈ºyca:</label>
                <input type="text" id="moonTextureUrl" placeholder="Wklej URL tekstury..." style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #555; background: #222; color: white; font-size: 0.8em; margin-bottom: 6px;">
                <div style="display: flex; gap: 6px;">
                    <button id="loadTextureButton" class="control-button" style="flex: 1;">üñºÔ∏è Za≈Çaduj</button>
                    <button id="clearTextureButton" class="control-button" style="flex: 1;">üåë Usu≈Ñ</button>
                </div>
            </div>
            
            <div class="button-row">
                <button id="playButton" class="control-button">‚ñ∂ Play</button>
                <button id="resetButton" class="control-button">‚ü≤ Reset</button>
                <button id="cameraToggleButton" class="control-button">üåå Kosmos</button>
                <button id="resetCameraButton" class="control-button">üì∑ Reset</button>
            </div>
            
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-label">Rok symulacji</div>
                    <div class="info-value" id="currentYear">2025</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Dzie≈Ñ roku</div>
                    <div class="info-value" id="dayOfYear">1</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Pora roku</div>
                    <div class="info-value" id="season">Zima</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Odleg≈Ço≈õƒá od S≈Ço≈Ñca</div>
                    <div class="info-value" id="earthDistance">147 mln km</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Odleg≈Ço≈õƒá Ksiƒô≈ºyca</div>
                    <div class="info-value" id="moonDistance">384 tys km</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Faza Ksiƒô≈ºyca</div>
                    <div class="info-value" id="moonPhaseShort">N√≥w</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Tryb kamery</div>
                    <div class="info-value" id="cameraMode">Ziemia</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Rozmiar S≈Ço≈Ñca</div>
                    <div class="info-value" id="sunSize">15x Ziemia</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Rozmiar Ksiƒô≈ºyca</div>
                    <div class="info-value" id="moonSize">0.27x Ziemia</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Nachylenie osi Ziemi</div>
                    <div class="info-value" id="earthTilt">23.5¬∞</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Nachylenie orbity Ksiƒô≈ºyca</div>
                    <div class="info-value" id="orbitalTilt">5.1¬∞</div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas3d"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Globalne zmienne
        let scene, camera, renderer;
        let sun, earth, moon;
        let planets = {}; // Obiekt do przechowywania wszystkich planet
        let planetOrbitGroups = {}; // Grupy orbit dla ka≈ºdej planety
        let earthOrbitGroup, earthTiltGroup, moonOrbitGroup;
        let sunLight;
        let textureLoader; // Globalny loader tekstur
        let animationRunning = true; // Uruchom animacjƒô od razu
        let lastAnimationTime = 0;
        let animationSpeed = 1; // 1 = normalna prƒôdko≈õƒá, 2 = 2x szybciej, 0.5 = 2x wolniej
        let cameraMode = 'earth'; // Dodaj inicjalizacjƒô trybu kamery
        
        // Kontrola kamery
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        let cameraDistance = 25; // Dostosowane dla wiƒôkszej orbity Ksiƒô≈ºyca
        let initialPinchDistance = 0;
        let initialCameraDistance = 0;
        
        // Parametry fizyczne i orbitalne (realistyczne proporcje!)
        // Skala: 1 AU = 50 jednostek w symulacji (zwiƒôkszona dla lepszego roz≈Ço≈ºenia)
        const sunRadius = 15; // 109x wiƒôkszy od Ziemi by≈Çby 109, ale to przys≈Çoni≈Çoby wszystko - kompromis na 15x
        
        // Dane planet uk≈Çadu s≈Çonecznego (RZECZYWISTE PROPORCJE!)
        const planetData = {
            mercury: {
                name: 'Merkury',
                radius: 0.38, // 0.38 √ó earthRadius (rzeczywista proporcja)
                orbitRadius: 19.5, // 0.39 AU √ó 50
                orbitPeriod: 88, // dni
                startAngle: 0, // Pozycja startowa w radianach
                color: 0x8c7853,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/4/4a/Mercury_in_true_color.jpg',
                    'https://upload.wikimedia.org/wikipedia/commons/d/d9/Mercury_in_color_-_Prockter07-edit.jpg'
                ]
            },
            venus: {
                name: 'Wenus', 
                radius: 0.95, // 0.95 √ó earthRadius (rzeczywista proporcja)
                orbitRadius: 36, // 0.72 AU √ó 50
                orbitPeriod: 225,
                startAngle: Math.PI * 0.3, // 54¬∞ offset
                color: 0xffc649,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/e/e5/Venus-real_color.jpg',
                    'https://upload.wikimedia.org/wikipedia/commons/8/85/Venus_globe.jpg'
                ]
            },
            earth: {
                name: 'Ziemia',
                radius: 1, // Referencja
                orbitRadius: 50, // 1.0 AU √ó 50  
                orbitPeriod: 365,
                startAngle: Math.PI * 0.6, // 108¬∞ offset
                color: 0x4fc3f7,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/5/56/Blue_Marble_Next_Generation_%2B_topography_%2B_bathymetry.jpg',
                    'https://upload.wikimedia.org/wikipedia/commons/9/97/The_Earth_seen_from_Apollo_17.jpg'
                ]
            },
            mars: {
                name: 'Mars',
                radius: 0.53, // 0.53 √ó earthRadius (rzeczywista proporcja)
                orbitRadius: 76, // 1.52 AU √ó 50
                orbitPeriod: 687,
                startAngle: Math.PI * 0.9, // 162¬∞ offset
                color: 0xcd5c5c,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/0/02/OSIRIS_Mars_true_color.jpg',
                    'https://upload.wikimedia.org/wikipedia/commons/5/58/Mars_23_aug_2003_hubble.jpg'
                ]
            },
            jupiter: {
                name: 'Jowisz',
                radius: 11.2, // 11.2 √ó earthRadius (rzeczywista proporcja - to bƒôdzie DU≈ªY!)
                orbitRadius: 260, // 5.2 AU √ó 50
                orbitPeriod: 4333, // 12 lat √ó 365 dni
                startAngle: Math.PI * 1.2, // 216¬∞ offset
                color: 0xd8ca9d,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/e/e1/Jupiter_by_Cassini-Huygens.jpg',
                    'https://upload.wikimedia.org/wikipedia/commons/2/2b/Jupiter_and_its_shrunken_Great_Red_Spot.jpg'
                ]
            },
            saturn: {
                name: 'Saturn',
                radius: 9.4, // 9.4 √ó earthRadius (rzeczywista proporcja)
                orbitRadius: 475, // 9.5 AU √ó 50
                orbitPeriod: 10585, // 29 lat √ó 365 dni
                startAngle: Math.PI * 1.5, // 270¬∞ offset
                color: 0xfad5a5,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/c/c7/Saturn_during_Equinox.jpg',
                    'https://upload.wikimedia.org/wikipedia/commons/c/c1/Saturn_from_Cassini_Orbiter_%282004-10-06%29.jpg'
                ]
            },
            uranus: {
                name: 'Uran',
                radius: 4.0, // 4.0 √ó earthRadius (rzeczywista proporcja)
                orbitRadius: 960, // 19.2 AU √ó 50
                orbitPeriod: 30660, // 84 lata √ó 365 dni
                startAngle: Math.PI * 1.8, // 324¬∞ offset
                color: 0x4fd0e3,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/3/3d/Uranus2.jpg',
                    'https://upload.wikimedia.org/wikipedia/commons/4/48/Uranus_as_seen_by_NASA%27s_Voyager_2_%28remastered%29_-_JPEG_converted.jpg'
                ]
            },
            neptune: {
                name: 'Neptun', 
                radius: 3.9, // 3.9 √ó earthRadius (rzeczywista proporcja)
                orbitRadius: 1505, // 30.1 AU √ó 50
                orbitPeriod: 60225, // 165 lat √ó 365 dni
                startAngle: Math.PI * 0.1, // 18¬∞ offset
                color: 0x4b70dd,
                textureUrls: [
                    'https://upload.wikimedia.org/wikipedia/commons/6/63/Neptune_-_Voyager_2_%2829347980845%29_flatten_crop.jpg',
                    'https://upload.wikimedia.org/wikipedia/commons/5/56/Neptune_full.jpg'
                ]
            }
        };
        
        const earthRadius = planetData.earth.radius;
        const moonRadius = 0.27; // 0.27 √ó earthRadius (rzeczywista proporcja)
        
        // Orbita Ziemi wok√≥≈Ç S≈Ço≈Ñca
        const earthOrbitRadius = planetData.earth.orbitRadius; // 50 jednostek
        const earthEccentricity = 0.0167; // ekscentryczno≈õƒá orbity Ziemi
        const earthAxialTilt = -23.5 * (Math.PI / 180); // nachylenie osi Ziemi (-23.5¬∞ dla prawid≈Çowych p√≥r roku)
        
        // Orbita Ksiƒô≈ºyca wok√≥≈Ç Ziemi (RZECZYWISTE PROPORCJE!)
        const moonOrbitRadius = 15; // 384,400 km = ~60 promieni Ziemi, ale kompromis wizualny na 15 jednostek
        const moonEccentricity = 0.055; // ekscentryczno≈õƒá orbity Ksiƒô≈ºyca
        const moonOrbitalTilt = 5.1 * (Math.PI / 180); // nachylenie orbity Ksiƒô≈ºyca (5.1¬∞)
        const moonTiltMultiplier = 3; // Zwiƒôkszmy wizualny efekt nachylenia dla lepszej widoczno≈õci
        
        const lunarCycleLength = 29.53;
        
        function init() {
            // Scena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // Kamera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 4, 8); // Bli≈ºej dla obserwacji Ziemia-Ksiƒô≈ºyc
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas3d'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // LOADER TEKSTUR - GLOBALNY
            textureLoader = new THREE.TextureLoader();
            
            // ≈öwiat≈Ço otoczenia (bardzo s≈Çabe)
            const ambientLight = new THREE.AmbientLight(0x202040, 0.05);
            scene.add(ambientLight);
            
            // S≈Ço≈Ñce z teksturƒÖ
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32);
            const sunMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffeb3b,
                emissive: 0xffaa00
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 0, 0);
            scene.add(sun);
            
            // Pr√≥ba za≈Çadowania tekstury S≈Ço≈Ñca z fallbackiem
            const sunTextureUrls = [
                'https://upload.wikimedia.org/wikipedia/commons/b/b4/The_Sun_by_the_Atmospheric_Imaging_Assembly_of_NASA%27s_Solar_Dynamics_Observatory_-_20100819.jpg',
                'https://upload.wikimedia.org/wikipedia/commons/9/99/Map_of_the_full_sun.jpg'
            ];
            
            function loadSunTexture(urls, index = 0) {
                if (!urls || index >= urls.length) {
                    console.log('‚ùå Wszystkie tekstury S≈Ço≈Ñca nieudane - u≈ºywam koloru ≈º√≥≈Çto-pomara≈Ñczowego');
                    return;
                }
                
                textureLoader.load(
                    urls[index],
                    function(texture) {
                        console.log(`‚úÖ Tekstura S≈Ço≈Ñca za≈Çadowana (${index + 1}/${urls.length})`);
                        sun.material.map = texture;
                        sun.material.color.setHex(0xffffff);
                        sun.material.needsUpdate = true;
                    },
                    undefined,
                    function(error) {
                        console.log(`‚ùå B≈ÇƒÖd tekstury S≈Ço≈Ñca (${index + 1}/${urls.length}), pr√≥bujƒô nastƒôpnƒÖ...`);
                        loadSunTexture(urls, index + 1);
                    }
                );
            }
            
            loadSunTexture(sunTextureUrls);
            
            // Efekt ≈õwiecenia wok√≥≈Ç S≈Ço≈Ñca
            const sunGlowGeometry = new THREE.SphereGeometry(sunRadius * 1.5, 32, 32);
            const sunGlowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00,
                transparent: true,
                opacity: 0.3
            });
            const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
            sunGlow.position.set(0, 0, 0);
            scene.add(sunGlow);
            
            // G≈Ç√≥wne ≈õwiat≈Ço s≈Çoneczne - PointLight (punktowe)
            const sunPointLight = new THREE.PointLight(0xffffff, 3, 100); // Zwiƒôkszona intensywno≈õƒá
            sunPointLight.position.set(0, 0, 0);
            sunPointLight.castShadow = true;
            sunPointLight.shadow.camera.near = 1;
            sunPointLight.shadow.camera.far = 50;
            sunPointLight.shadow.mapSize.width = 2048;
            sunPointLight.shadow.mapSize.height = 2048;
            scene.add(sunPointLight);
            
            // Dodatkowe ≈õwiat≈Ço kierunkowe dla lepszego o≈õwietlenia
            sunLight = new THREE.DirectionalLight(0xffffff, 0.8); // Zmniejszona intensywno≈õƒá kierunkowego
            sunLight.position.set(1, 0.5, 0.5);
            sunLight.target.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -30;
            sunLight.shadow.camera.right = 30;
            sunLight.shadow.camera.top = 30;
            sunLight.shadow.camera.bottom = -30;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            scene.add(sunLight.target);
            
            // Orbita Ziemi wok√≥≈Ç S≈Ço≈Ñca
            earthOrbitGroup = new THREE.Group();
            scene.add(earthOrbitGroup);
            
            // Grupa dla nachylenia osi Ziemi (sta≈Çe w przestrzeni)
            earthTiltGroup = new THREE.Group();
            earthTiltGroup.rotation.z = earthAxialTilt; // Nachylenie 23.5¬∞ - sta≈Çe w przestrzeni
            earthOrbitGroup.add(earthTiltGroup);
            
            // Ziemia z teksturƒÖ mapy ≈õwiata
            const earthGeometry = new THREE.SphereGeometry(earthRadius, 64, 64);
            
            // Domy≈õlny materia≈Ç Ziemi
            const earthMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4fc3f7, // Domy≈õlny kolor je≈õli tekstura siƒô nie za≈Çaduje
                emissive: 0x000022
            });
            
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.position.set(0, 0, 0); // Ziemia w centrum swojej grupy
            earth.castShadow = true;
            earth.receiveShadow = true;
            earthTiltGroup.add(earth); // Dodaj do grupy z nachyleniem
            
            // Pr√≥ba za≈Çadowania tekstury Ziemi z fallbackiem
            const earthTextureUrls = planetData.earth.textureUrls;
            function loadEarthTexture(urls, index = 0) {
                if (!urls || index >= urls.length) {
                    console.log('‚ùå Wszystkie tekstury Ziemi nieudane - u≈ºywam koloru niebieskiego oceanu');
                    return;
                }
                
                textureLoader.load(
                    urls[index],
                    function(texture) {
                        console.log(`‚úÖ Tekstura Ziemi za≈Çadowana (${index + 1}/${urls.length})`);
                        earth.material.map = texture;
                        earth.material.color.setHex(0xffffff); // Bia≈Çe o≈õwietlenie dla naturalnych kolor√≥w
                        earth.material.needsUpdate = true;
                    },
                    function(progress) {
                        console.log('≈Åadowanie tekstury Ziemi:', Math.round(progress.loaded / progress.total * 100) + '%');
                    },
                    function(error) {
                        console.log(`‚ùå B≈ÇƒÖd tekstury Ziemi (${index + 1}/${urls.length}), pr√≥bujƒô nastƒôpnƒÖ...`);
                        loadEarthTexture(urls, index + 1);
                    }
                );
            }
            
            loadEarthTexture(earthTextureUrls);
            
            // Orbita Ksiƒô≈ºyca wok√≥≈Ç Ziemi - PRZENIESIONE Z addContinents()
            moonOrbitGroup = new THREE.Group();
            moonOrbitGroup.position.set(0, 0, 0); // Centruj na Ziemi
            earthTiltGroup.add(moonOrbitGroup); // Ksiƒô≈ºyc podƒÖ≈ºa za nachylonƒÖ ZiemiƒÖ
            
            // Ksiƒô≈ºyc z teksturƒÖ
            const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
            
            // Domy≈õlny materia≈Ç Ksiƒô≈ºyca
            const moonMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xe0e0e0, // Domy≈õlny szary kolor
                emissive: 0x111111
            });
            
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(moonOrbitRadius, 0, 0);
            moon.castShadow = true;
            moon.receiveShadow = true;
            moonOrbitGroup.add(moon);
            
            // Nie ≈Çadujemy tekstury Ksiƒô≈ºyca - zostawiamy czysty szary materia≈Ç
            // dla lepszej edukacyjnej wizualizacji faz (bez mylƒÖcych ciemnych plam)
            console.log('üí° Ksiƒô≈ºyc bez tekstury - czyste fazy ≈õwietlne od S≈Ço≈Ñca!');
            
            // Linie orbit
            createOrbitLines();
            
            // Stw√≥rz wszystkie planety
            createPlanets();
            
            // Gwiazdy
            createStars();
            
            // Event listeners
            setupEventListeners();
        }
        
        function createOrbitLines() {
            // Orbity wszystkich planet
            Object.keys(planetData).forEach(planetKey => {
                const planet = planetData[planetKey];
                const orbitPoints = [];
                
                for (let i = 0; i <= 128; i++) {
                    const angle = (i / 128) * Math.PI * 2;
                    // U≈ºywamy ma≈Çej ekscentryczno≈õci dla wszystkich orbit (uproszczenie)
                    const eccentricity = planetKey === 'earth' ? earthEccentricity : 0.01;
                    const distance = planet.orbitRadius * (1 - eccentricity * Math.cos(angle));
                    orbitPoints.push(new THREE.Vector3(
                        Math.cos(angle) * distance,
                        0,
                        Math.sin(angle) * distance
                    ));
                }
                
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                const orbitMaterial = new THREE.LineBasicMaterial({ 
                    color: planetKey === 'earth' ? 0x888888 : 0x444444,
                    transparent: true,
                    opacity: planetKey === 'earth' ? 0.6 : 0.3
                });
                const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                scene.add(orbitLine);
            });
            
            // ORBITA KSIƒò≈ªYCA (specjalna - nachylona) - MUSI ZGADZAƒÜ SIƒò Z updatePositions()
            const moonOrbitPoints = [];
            for (let i = 0; i <= 128; i++) {
                const angle = (i / 128) * Math.PI * 2;
                const distance = moonOrbitRadius * (1 - moonEccentricity * Math.cos(angle));
                
                // Zastosuj nachylenie orbity IDENTYCZNIE jak w updatePositions()
                const x = Math.cos(angle) * distance;
                const y = Math.sin(angle) * distance * Math.sin(moonOrbitalTilt) * moonTiltMultiplier; // DODAJ moonTiltMultiplier!
                const z = Math.sin(angle) * distance * Math.cos(moonOrbitalTilt);
                
                moonOrbitPoints.push(new THREE.Vector3(x, y, z));
            }
            const moonOrbitGeometry = new THREE.BufferGeometry().setFromPoints(moonOrbitPoints);
            const moonOrbitMaterial = new THREE.LineBasicMaterial({ 
                color: 0x666666,
                transparent: true,
                opacity: 0.5
            });
            const moonOrbitLine = new THREE.Line(moonOrbitGeometry, moonOrbitMaterial);
            earthOrbitGroup.add(moonOrbitLine); // Orbita ksiƒô≈ºyca podƒÖ≈ºa za ZiemiƒÖ (ale bez nachylenia)
        }
        
        function createPlanets() {
            // Funkcja pomocnicza do ≈Çadowania tekstur z fallbackiem
            function loadTextureWithFallback(planet, planetInfo, urls, index = 0) {
                if (!urls || index >= urls.length) {
                    console.log(`‚ùå Wszystkie tekstury ${planetInfo.name} nieudane - u≈ºywam koloru`);
                    return;
                }
                
                textureLoader.load(
                    urls[index],
                    function(texture) {
                        console.log(`‚úÖ Tekstura ${planetInfo.name} za≈Çadowana (${index + 1}/${urls.length})`);
                        planet.material.map = texture;
                        planet.material.color.setHex(0xffffff);
                        planet.material.needsUpdate = true;
                    },
                    function(progress) {
                        console.log(`≈Åadowanie tekstury ${planetInfo.name}...`, Math.round(progress.loaded / progress.total * 100) + '%');
                    },
                    function(error) {
                        console.log(`‚ùå B≈ÇƒÖd tekstury ${planetInfo.name} (${index + 1}/${urls.length}), pr√≥bujƒô nastƒôpnƒÖ...`);
                        loadTextureWithFallback(planet, planetInfo, urls, index + 1);
                    }
                );
            }
            
            Object.keys(planetData).forEach(planetKey => {
                if (planetKey === 'earth') return; // Ziemia ju≈º istnieje
                
                const planetInfo = planetData[planetKey];
                
                // Grupa orbity dla planety
                const orbitGroup = new THREE.Group();
                scene.add(orbitGroup);
                planetOrbitGroups[planetKey] = orbitGroup;
                
                // Geometria i materia≈Ç planety
                const geometry = new THREE.SphereGeometry(planetInfo.radius, 32, 32);
                const material = new THREE.MeshLambertMaterial({ 
                    color: planetInfo.color,
                    emissive: 0x111111
                });
                
                const planet = new THREE.Mesh(geometry, material);
                // Ustaw pozycjƒô startowƒÖ z offsetem kƒÖtowym
                const startX = Math.cos(planetInfo.startAngle) * planetInfo.orbitRadius;
                const startZ = Math.sin(planetInfo.startAngle) * planetInfo.orbitRadius;
                planet.position.set(startX, 0, startZ);
                planet.castShadow = true;
                planet.receiveShadow = true;
                orbitGroup.add(planet);
                
                planets[planetKey] = planet;
                
                // ≈Åadowanie tekstury z systemem fallback
                if (planetInfo.textureUrls) {
                    loadTextureWithFallback(planet, planetInfo, planetInfo.textureUrls);
                }
            });
        }
        
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 800;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 200;
                positions[i + 1] = (Math.random() - 0.5) * 200;
                positions[i + 2] = (Math.random() - 0.5) * 200;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff,
                size: 1.5,
                sizeAttenuation: false
            });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        function updateSpeedDisplay() {
            const speedDisplay = document.getElementById('speedDisplay');
            const dayDuration = document.getElementById('dayDuration');
            
            if (speedDisplay) {
                speedDisplay.textContent = animationSpeed.toFixed(1) + 'x';
            }
            if (dayDuration) {
                const duration = (3 / animationSpeed).toFixed(1);
                dayDuration.textContent = duration + 's';
            }
        }
        
        function resetCamera() {
            targetRotationX = 0;
            targetRotationY = 0;
            if (cameraMode === 'earth') {
                cameraDistance = 15; // Zwiƒôkszone dla wiƒôkszej Ziemi
            } else {
                cameraDistance = 400; // Znacznie wiƒôksza odleg≈Ço≈õƒá dla ca≈Çego uk≈Çadu
            }
        }
        
        function toggleCameraMode() {
            if (cameraMode === 'earth') {
                cameraMode = 'space';
                cameraDistance = 400; // Wiƒôksza odleg≈Ço≈õƒá dla ca≈Çego uk≈Çadu
                targetRotationX = 0.3;
                targetRotationY = 0;
            } else {
                cameraMode = 'earth';
                cameraDistance = 15; // Bli≈ºej dla systemu Ziemia-Ksiƒô≈ºyc
                targetRotationX = 0;
                targetRotationY = 0;
            }
            updateCameraModeUI();
        }
        
        function updateCameraModeUI() {
            const cameraToggleButton = document.getElementById('cameraToggleButton');
            const cameraModeElement = document.getElementById('cameraMode');
            const cameraModeText = document.getElementById('cameraModeText');
            
            if (cameraToggleButton) {
                cameraToggleButton.innerHTML = cameraMode === 'earth' ? 'üåå Kosmos' : 'üåç Ziemia';
            }
            if (cameraModeElement) {
                cameraModeElement.textContent = cameraMode === 'earth' ? 'Ziemia' : 'Kosmos';
            }
            if (cameraModeText) {
                cameraModeText.textContent = cameraMode === 'earth' ? 'Widok z Ziemi' : 'Widok z Kosmosu';
            }
        }
        
        function loadMoonTexture() {
            const url = document.getElementById('moonTextureUrl').value.trim();
            if (!url) {
                alert('Wklej URL tekstury Ksiƒô≈ºyca!');
                return;
            }
            
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                url,
                function(texture) {
                    console.log('‚úÖ Nowa tekstura Ksiƒô≈ºyca za≈Çadowana!');
                    moon.material.map = texture;
                    moon.material.color.setHex(0xffffff);
                    moon.material.needsUpdate = true;
                },
                function(progress) {
                    console.log('≈Åadowanie tekstury...', Math.round(progress.loaded / progress.total * 100) + '%');
                },
                function(error) {
                    console.log('‚ùå B≈ÇƒÖd ≈Çadowania tekstury:', error);
                    alert('Nie uda≈Ço siƒô za≈Çadowaƒá tekstury. Sprawd≈∫ URL i upewnij siƒô, ≈ºe obraz jest dostƒôpny.');
                }
            );
        }
        
        function clearMoonTexture() {
            moon.material.map = null;
            moon.material.color.setHex(0xe0e0e0); // Powr√≥t do szarego
            moon.material.needsUpdate = true;
            document.getElementById('moonTextureUrl').value = '';
            console.log('üåë Tekstura Ksiƒô≈ºyca usuniƒôta - czysty szary materia≈Ç');
        }
        
        function setupEventListeners() {
            const canvas = document.getElementById('canvas3d');
            const timeSlider = document.getElementById('timeSlider');
            const speedSlider = document.getElementById('speedSlider');
            const playButton = document.getElementById('playButton');
            const resetButton = document.getElementById('resetButton');
            const resetCameraButton = document.getElementById('resetCameraButton');
            const cameraToggleButton = document.getElementById('cameraToggleButton');
            const mobileToggle = document.getElementById('mobileToggle');
            const controlPanel = document.getElementById('controlPanel');
            const loadTextureButton = document.getElementById('loadTextureButton');
            const clearTextureButton = document.getElementById('clearTextureButton');
            const moonTextureUrl = document.getElementById('moonTextureUrl');
            
            // Mobile toggle
            mobileToggle.addEventListener('click', function() {
                const isCollapsed = controlPanel.classList.contains('mobile-collapsed');
                if (isCollapsed) {
                    controlPanel.classList.remove('mobile-collapsed');
                    mobileToggle.innerHTML = '<div>‚úï Zamknij</div><div class="toggle-info" id="toggleInfo"></div>';
                } else {
                    controlPanel.classList.add('mobile-collapsed');
                    mobileToggle.innerHTML = '<div>‚öôÔ∏è Options</div><div class="toggle-info" id="toggleInfo"></div>';
                }
                updateToggleInfo();
            });
            
            // Kontrola myszƒÖ
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            
            // Kontrola dotykiem
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);
            
            // Suwak czasu
            timeSlider.addEventListener('input', function(e) {
                const totalDays = parseFloat(e.target.value);
                updatePositions(totalDays);
                updateUIOnly(totalDays);
            });
            
            // Suwak prƒôdko≈õci
            speedSlider.addEventListener('input', function(e) {
                animationSpeed = parseFloat(e.target.value);
                updateSpeedDisplay();
            });
            
            // Przyciski
            playButton.addEventListener('click', toggleAnimation);
            resetButton.addEventListener('click', resetAnimation);
            resetCameraButton.addEventListener('click', resetCamera);
            cameraToggleButton.addEventListener('click', toggleCameraMode);
            loadTextureButton.addEventListener('click', loadMoonTexture);
            clearTextureButton.addEventListener('click', clearMoonTexture);
            
            // Enter w polu tekstury r√≥wnie≈º ≈Çaduje
            moonTextureUrl.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    loadMoonTexture();
                }
            });
            
            // Responsywno≈õƒá
            window.addEventListener('resize', onWindowResize);
            
            // Inicjalizacja mobile UI
            initializeMobileUI();
        }
        
        function initializeMobileUI() {
            const controlPanel = document.getElementById('controlPanel');
            const mobileToggle = document.getElementById('mobileToggle');
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                controlPanel.classList.add('mobile-collapsed');
                mobileToggle.style.display = 'block';
            } else {
                controlPanel.classList.remove('mobile-collapsed');
                mobileToggle.style.display = 'none';
            }
            updateToggleInfo();
        }
        
        // Kontrola kamery
        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            targetRotationY += deltaX * 0.01;
            targetRotationX += deltaY * 0.01;
            targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp() {
            isMouseDown = false;
        }
        
        function onMouseWheel(event) {
            cameraDistance += event.deltaY * 0.05; // Zwiƒôkszony krok dla znacznie wiƒôkszych odleg≈Ço≈õci
            if (cameraMode === 'earth') {
                cameraDistance = Math.max(8, Math.min(80, cameraDistance)); // Zwiƒôkszone dla wiƒôkszej orbity Ksiƒô≈ºyca
            } else {
                cameraDistance = Math.max(100, Math.min(2000, cameraDistance)); // Znacznie zwiƒôkszone dla ca≈Çego uk≈Çadu
            }
        }
        
        // Dotyk
        let touchStartX = 0, touchStartY = 0;
        
        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                // Pojedynczy dotyk - obracanie
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                isMouseDown = true;
            } else if (event.touches.length === 2) {
                // Pinch to zoom
                initialPinchDistance = getPinchDistance(event.touches);
                initialCameraDistance = cameraDistance;
                isMouseDown = false;
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            
            if (event.touches.length === 1 && isMouseDown) {
                // Obracanie
                const deltaX = event.touches[0].clientX - touchStartX;
                const deltaY = event.touches[0].clientY - touchStartY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                // Pinch to zoom
                const currentPinchDistance = getPinchDistance(event.touches);
                const pinchRatio = currentPinchDistance / initialPinchDistance;
                cameraDistance = initialCameraDistance / pinchRatio;
                
                if (cameraMode === 'earth') {
                    cameraDistance = Math.max(8, Math.min(80, cameraDistance)); // Zwiƒôkszone dla wiƒôkszej orbity Ksiƒô≈ºyca
                } else {
                    cameraDistance = Math.max(100, Math.min(2000, cameraDistance)); // Znacznie zwiƒôkszone limity
                }
            }
        }
        
        function onTouchEnd(event) {
            if (event.touches.length === 0) {
                isMouseDown = false;
            }
        }
        
        function updateCameraPosition() {
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            
            if (cameraMode === 'earth') {
                // Kamera podƒÖ≈ºa za ZiemiƒÖ (uwzglƒôdniajƒÖc nachylenie)
                const earthPos = earthOrbitGroup.position;
                
                const x = earthPos.x + Math.cos(currentRotationX) * Math.sin(currentRotationY) * cameraDistance;
                const y = earthPos.y + Math.sin(currentRotationX) * cameraDistance;
                const z = earthPos.z + Math.cos(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
                
                camera.position.set(x, y, z);
                camera.lookAt(earthPos.x, earthPos.y, earthPos.z);
            } else {
                // Widok z kosmosu (centrum uk≈Çadu) - zwiƒôkszone odleg≈Ço≈õci
                const x = Math.cos(currentRotationX) * Math.sin(currentRotationY) * cameraDistance;
                const y = Math.sin(currentRotationX) * cameraDistance;
                const z = Math.cos(currentRotationX) * Math.cos(currentRotationY) * cameraDistance;
                
                camera.position.set(x, y, z);
                camera.lookAt(0, 0, 0);
            }
        }
        
        function updatePositions(totalDays) {
            // AKTUALIZUJ WSZYSTKIE PLANETY - u≈ºyj totalDays zamiast dayOfYear
            Object.keys(planetData).forEach(planetKey => {
                const planetInfo = planetData[planetKey];
                
                if (planetKey === 'earth') {
                    // ORBITA ZIEMI WOK√ì≈Å S≈ÅO≈ÉCA (eliptyczna)
                    const earthOrbitAngle = (totalDays / planetInfo.orbitPeriod) * 2 * Math.PI + planetInfo.startAngle;
                    
                    // Oblicz eliptycznƒÖ odleg≈Ço≈õƒá od S≈Ço≈Ñca
                    const earthDistance = earthOrbitRadius * (1 - earthEccentricity * Math.cos(earthOrbitAngle));
                    
                    // Pozycja ca≈Çej grupy Ziemi na eliptycznej orbicie
                    const earthX = Math.cos(earthOrbitAngle) * earthDistance;
                    const earthZ = Math.sin(earthOrbitAngle) * earthDistance;
                    earthOrbitGroup.position.set(earthX, 0, earthZ);
                    
                    // ROTACJA ZIEMI WOK√ì≈Å OSI (doba) - nachylenie jest ju≈º ustawione w earthTiltGroup
                    const dayProgress = totalDays % 1;
                    earth.rotation.y = dayProgress * 2 * Math.PI;
                } else {
                    // INNE PLANETY
                    const orbitAngle = (totalDays / planetInfo.orbitPeriod) * 2 * Math.PI + planetInfo.startAngle;
                    const eccentricity = 0.01; // Uproszczona ekscentryczno≈õƒá
                    const distance = planetInfo.orbitRadius * (1 - eccentricity * Math.cos(orbitAngle));
                    
                    const x = Math.cos(orbitAngle) * distance;
                    const z = Math.sin(orbitAngle) * distance;
                    
                    if (planets[planetKey]) {
                        planets[planetKey].position.set(x, 0, z);
                    }
                    
                    // Rotacja planety wok√≥≈Ç w≈Çasnej osi (uproszczona - 1 obr√≥t na dobƒô ziemskƒÖ)
                    if (planets[planetKey]) {
                        const dayProgress = totalDays % 1;
                        planets[planetKey].rotation.y = dayProgress * 2 * Math.PI;
                    }
                }
            });
            
            // ORBITA KSIƒò≈ªYCA WOK√ì≈Å ZIEMI - CIƒÑG≈ÅA PRZEZ LATA (bez reset√≥w!)
            const moonOrbitAngle = (totalDays / lunarCycleLength) * 2 * Math.PI;
            
            // Oblicz eliptycznƒÖ odleg≈Ço≈õƒá Ksiƒô≈ºyca od Ziemi
            const moonDistance = moonOrbitRadius * (1 - moonEccentricity * Math.cos(moonOrbitAngle));
            
            // Pozycja Ksiƒô≈ºyca z nachyleniem orbity (5.1¬∞ x3 dla lepszej widoczno≈õci) wzglƒôdem Ziemi
            const moonX = Math.cos(moonOrbitAngle) * moonDistance;
            const moonY = Math.sin(moonOrbitAngle) * moonDistance * Math.sin(moonOrbitalTilt) * moonTiltMultiplier;
            const moonZ = Math.sin(moonOrbitAngle) * moonDistance * Math.cos(moonOrbitalTilt);
            
            moon.position.set(moonX, moonY, moonZ);
            
            // Synchroniczna rotacja Ksiƒô≈ºyca (zawsze ta sama strona do Ziemi)
            moon.rotation.y = moonOrbitAngle;
            
            return { 
                earthOrbitAngle: (totalDays / planetData.earth.orbitPeriod) * 2 * Math.PI + planetData.earth.startAngle, 
                moonOrbitAngle, 
                earthDistance: earthOrbitRadius * (1 - earthEccentricity * Math.cos((totalDays / planetData.earth.orbitPeriod) * 2 * Math.PI + planetData.earth.startAngle)), 
                moonDistance 
            };
        }
        
        function getMoonPhase(totalDays) {
            // Oblicz rzeczywiste pozycje w 3D dla prawid≈Çowych faz - u≈ºywaj ciƒÖg≈Çego czasu!
            const earthOrbitAngle = (totalDays / planetData.earth.orbitPeriod) * 2 * Math.PI + planetData.earth.startAngle;
            const moonOrbitAngle = (totalDays / lunarCycleLength) * 2 * Math.PI; // CIƒÑG≈ÅY CZAS
            
            // Pozycja Ziemi wzglƒôdem S≈Ço≈Ñca (u≈ºywaj aktualnych warto≈õci)
            const earthDistance = earthOrbitRadius * (1 - earthEccentricity * Math.cos(earthOrbitAngle));
            const earthX = Math.cos(earthOrbitAngle) * earthDistance;
            const earthZ = Math.sin(earthOrbitAngle) * earthDistance;
            
            // Pozycja Ksiƒô≈ºyca wzglƒôdem Ziemi (u≈ºywaj aktualnych warto≈õci moonOrbitRadius = 15)
            const moonDistance = moonOrbitRadius * (1 - moonEccentricity * Math.cos(moonOrbitAngle));
            const moonLocalX = Math.cos(moonOrbitAngle) * moonDistance;
            const moonLocalZ = Math.sin(moonOrbitAngle) * moonDistance * Math.cos(moonOrbitalTilt);
            
            // Pozycja Ksiƒô≈ºyca wzglƒôdem S≈Ço≈Ñca (globalna)
            const moonGlobalX = earthX + moonLocalX;
            const moonGlobalZ = earthZ + moonLocalZ;
            
            // Wektor od S≈Ço≈Ñca do Ziemi
            const sunToEarth = { x: earthX, z: earthZ };
            
            // Wektor od Ziemi do Ksiƒô≈ºyca  
            const earthToMoon = { x: moonLocalX, z: moonLocalZ };
            
            // KƒÖt fazowy (kƒÖt miƒôdzy wektorami)
            const dotProduct = sunToEarth.x * earthToMoon.x + sunToEarth.z * earthToMoon.z;
            const sunEarthMag = Math.sqrt(sunToEarth.x * sunToEarth.x + sunToEarth.z * sunToEarth.z);
            const earthMoonMag = Math.sqrt(earthToMoon.x * earthToMoon.x + earthToMoon.z * earthToMoon.z);
            
            const cosAngle = dotProduct / (sunEarthMag * earthMoonMag);
            const phaseAngle = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
            
            // Okre≈õl fazƒô na podstawie kƒÖta fazowego
            // 0¬∞ = Pe≈Çnia (Ksiƒô≈ºyc za ZiemiƒÖ od S≈Ço≈Ñca)
            // 180¬∞ = N√≥w (Ksiƒô≈ºyc miƒôdzy ZiemiƒÖ a S≈Ço≈Ñcem)
            if (phaseAngle < 22.5 || phaseAngle >= 337.5) return { name: 'Pe≈Çnia', illumination: 100 };
            if (phaseAngle < 67.5) return { name: 'UbywajƒÖcy garb', illumination: 75 };
            if (phaseAngle < 112.5) return { name: 'Ostatnia kwadra', illumination: 50 };
            if (phaseAngle < 157.5) return { name: 'Stary sierp', illumination: 25 };
            if (phaseAngle < 202.5) return { name: 'N√≥w', illumination: 0 };
            if (phaseAngle < 247.5) return { name: 'M≈Çody sierp', illumination: 25 };
            if (phaseAngle < 292.5) return { name: 'Pierwsza kwadra', illumination: 50 };
            return { name: 'PrzybywajƒÖcy garb', illumination: 75 };
        }
        
        function updateUI(dayOfYear) {
            const angles = updatePositions(dayOfYear);
            const phase = getMoonPhase(dayOfYear); // U≈ºywaj nowej funkcji
            
            const date = new Date(2025, 0, dayOfYear + 1);
            const dateStr = date.toLocaleDateString('pl-PL', { day: 'numeric', month: 'long' });
            
            document.getElementById('currentDate').textContent = dateStr;
            document.getElementById('moonPhase').textContent = phase.name;
            document.getElementById('illumination').textContent = phase.illumination + '%';
            document.getElementById('currentYear').textContent = currentYear;
            document.getElementById('dayOfYear').textContent = Math.floor(dayOfYear) + 1;
            
            updateToggleInfo();
        }
        
        function updateToggleInfo() {
            const toggleInfo = document.getElementById('toggleInfo');
            if (toggleInfo) {
                const totalDays = parseFloat(document.getElementById('timeSlider').value);
                const phase = getMoonPhase(totalDays); // U≈ºyj totalDays
                const currentYear = Math.floor(totalDays / 365.25) + 2025;
                const dayOfYear = totalDays % 365.25;
                const date = new Date(currentYear, 0, Math.floor(dayOfYear) + 1);
                const shortDate = date.toLocaleDateString('pl-PL', { day: 'numeric', month: 'short', year: '2-digit' });
                const season = getSeason(dayOfYear);
                toggleInfo.textContent = shortDate + ' ‚Ä¢ ' + season + ' ‚Ä¢ ' + phase.name;
            }
        }
        
        function toggleAnimation() {
            const playButton = document.getElementById('playButton');
            
            if (!animationRunning) {
                animationRunning = true;
                playButton.textContent = '‚è∏ Pauza';
                lastAnimationTime = performance.now();
            } else {
                animationRunning = false;
                playButton.textContent = '‚ñ∂ Play';
            }
        }
        
        function resetAnimation() {
            animationRunning = false;
            document.getElementById('playButton').textContent = '‚ñ∂ Play';
            document.getElementById('timeSlider').value = 0;
            document.getElementById('speedSlider').value = 1;
            animationSpeed = 1;
            updatePositions(0);
            updateUIOnly(0);
            updateSpeedDisplay();
        }
        
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            // UI responsywno≈õƒá
            const controlPanel = document.getElementById('controlPanel');
            const mobileToggle = document.getElementById('mobileToggle');
            const isMobile = width <= 768;
            
            if (isMobile) {
                mobileToggle.style.display = 'block';
            } else {
                mobileToggle.style.display = 'none';
                controlPanel.classList.remove('mobile-collapsed');
            }
            
            // Zapisz tryb kamery podczas resize
            updateCameraModeUI();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updateCameraPosition();
            
            // Animacja ≈õwiecenia S≈Ço≈Ñca
            if (sun && sun.material && sun.material.emissive) {
                const time = performance.now() * 0.001;
                const intensity = 0.8 + Math.sin(time) * 0.2;
                sun.material.emissive.setRGB(1.0 * intensity, 0.5 * intensity, 0.0);
            }
            
            // Animacja - prƒôdko≈õƒá zale≈ºna od suwaka (domy≈õlnie 1 dzie≈Ñ co 3 sekundy)
            if (animationRunning) {
                const currentTime = performance.now();
                const deltaTime = currentTime - lastAnimationTime;
                const adjustedDuration = 3000 / animationSpeed; // Prƒôdko≈õƒá wp≈Çywa na czas doby
                
                if (deltaTime >= adjustedDuration) {
                    // Przejd≈∫ do nastƒôpnego dnia
                    const timeSlider = document.getElementById('timeSlider');
                    let currentDay = parseFloat(timeSlider.value);
                    currentDay += 1;
                    
                    if (currentDay > 10950) { // 30 lat
                        currentDay = 0;
                    }
                    
                    timeSlider.value = currentDay;
                    updateUIOnly(currentDay);
                    lastAnimationTime = currentTime;
                } else {
                    // P≈Çynna interpolacja wszystkich ruch√≥w
                    const dayProgress = deltaTime / adjustedDuration; // 0-1 przez dostosowany czas
                    const currentDay = parseFloat(document.getElementById('timeSlider').value);
                    const interpolatedDay = currentDay + dayProgress;
                    
                    // Aktualizuj pozycje wszystkich planet u≈ºywajƒÖc totalDays
                    Object.keys(planetData).forEach(planetKey => {
                        const planetInfo = planetData[planetKey];
                        
                        if (planetKey === 'earth') {
                            // P≈Çynny ruch Ziemi wok√≥≈Ç S≈Ço≈Ñca
                            const earthOrbitAngle = (interpolatedDay / planetInfo.orbitPeriod) * 2 * Math.PI + planetInfo.startAngle;
                            const earthDistance = earthOrbitRadius * (1 - earthEccentricity * Math.cos(earthOrbitAngle));
                            const earthX = Math.cos(earthOrbitAngle) * earthDistance;
                            const earthZ = Math.sin(earthOrbitAngle) * earthDistance;
                            earthOrbitGroup.position.set(earthX, 0, earthZ);
                            
                            // P≈Çynna rotacja Ziemi wok√≥≈Ç osi
                            const dayRotationProgress = interpolatedDay % 1;
                            earth.rotation.y = dayRotationProgress * 2 * Math.PI;
                        } else {
                            // P≈Çynny ruch innych planet
                            const orbitAngle = (interpolatedDay / planetInfo.orbitPeriod) * 2 * Math.PI + planetInfo.startAngle;
                            const eccentricity = 0.01;
                            const distance = planetInfo.orbitRadius * (1 - eccentricity * Math.cos(orbitAngle));
                            
                            const x = Math.cos(orbitAngle) * distance;
                            const z = Math.sin(orbitAngle) * distance;
                            
                            if (planets[planetKey]) {
                                planets[planetKey].position.set(x, 0, z);
                            }
                            
                            // Rotacja planety
                            if (planets[planetKey]) {
                                const dayRotationProgress = interpolatedDay % 1;
                                planets[planetKey].rotation.y = dayRotationProgress * 2 * Math.PI;
                            }
                        }
                    });
                    
                    // P≈Çynny ruch Ksiƒô≈ºyca - CIƒÑG≈ÅY PRZEZ LATA
                    const moonOrbitAngle = (interpolatedDay / lunarCycleLength) * 2 * Math.PI;
                    const moonDistance = moonOrbitRadius * (1 - moonEccentricity * Math.cos(moonOrbitAngle));
                    
                    const moonX = Math.cos(moonOrbitAngle) * moonDistance;
                    const moonY = Math.sin(moonOrbitAngle) * moonDistance * Math.sin(moonOrbitalTilt) * moonTiltMultiplier;
                    const moonZ = Math.sin(moonOrbitAngle) * moonDistance * Math.cos(moonOrbitalTilt);
                    
                    moon.position.set(moonX, moonY, moonZ);
                    moon.rotation.y = moonOrbitAngle;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        function getSeason(dayOfYear) {
            // Pory roku na p√≥≈Çkuli p√≥≈Çnocnej (w oparciu o rzeczywiste daty)
            // 1 stycznia = dzie≈Ñ 0 (zima), przesilenie zimowe ~21 grudnia (dzie≈Ñ 355)
            if (dayOfYear >= 355 || dayOfYear < 79) return 'Zima'; // 21 gru - 20 mar
            if (dayOfYear >= 79 && dayOfYear < 172) return 'Wiosna'; // 20 mar - 21 cze  
            if (dayOfYear >= 172 && dayOfYear < 266) return 'Lato'; // 21 cze - 23 wrz
            return 'Jesie≈Ñ'; // 23 wrz - 21 gru
        }
        
        function updateUIOnly(totalDays) {
            const phase = getMoonPhase(totalDays); // U≈ºywaj totalDays!
            
            // Przelicz totalDays na rok i dzie≈Ñ roku dla wy≈õwietlania
            const currentYear = Math.floor(totalDays / 365.25) + 2025;
            const dayOfYear = totalDays % 365.25;
            
            // Oblicz realistyczne odleg≈Ço≈õci
            const earthOrbitAngle = (totalDays / planetData.earth.orbitPeriod) * 2 * Math.PI + planetData.earth.startAngle;
            const moonOrbitAngle = (totalDays / lunarCycleLength) * 2 * Math.PI;
            
            const earthDistanceAU = earthOrbitRadius * (1 - earthEccentricity * Math.cos(earthOrbitAngle));
            const earthDistanceKm = Math.round(earthDistanceAU * 3); // Przeliczenie na rzeczywiste miliony km
            
            const moonDistanceScale = moonOrbitRadius * (1 - moonEccentricity * Math.cos(moonOrbitAngle));
            const moonDistanceKm = Math.round(moonDistanceScale * 25.6); // Przeliczenie: 15 jednostek = ~384 tys km
            
            // Oblicz datƒô na podstawie dnia roku
            const date = new Date(currentYear, 0, Math.floor(dayOfYear) + 1);
            const dateStr = date.toLocaleDateString('pl-PL', { day: 'numeric', month: 'long', year: 'numeric' });
            
            document.getElementById('currentDate').textContent = dateStr;
            document.getElementById('moonPhase').textContent = phase.name;
            document.getElementById('illumination').textContent = phase.illumination + '%';
            document.getElementById('dayOfYear').textContent = Math.floor(dayOfYear) + 1;
            
            // Nowe informacje
            document.getElementById('season').textContent = getSeason(dayOfYear);
            document.getElementById('earthDistance').textContent = earthDistanceKm + ' mln km';
            document.getElementById('moonDistance').textContent = moonDistanceKm + ' tys km';
            document.getElementById('moonPhaseShort').textContent = phase.name;
            document.getElementById('cameraMode').textContent = cameraMode === 'earth' ? 'Ziemia' : 'Kosmos';
            document.getElementById('earthTilt').textContent = '23.5¬∞'; // Sta≈Çe nachylenie osi Ziemi
            
            // Informacja o nachyleniu orbity Ksiƒô≈ºyca (nie osi Ziemi)
            const moonHeight = Math.sin(moonOrbitAngle) * Math.sin(moonOrbitalTilt) * moonTiltMultiplier;
            const moonTiltInfo = moonHeight > 0 ? '‚Üó +5.1¬∞' : moonHeight < 0 ? '‚Üò -5.1¬∞' : '‚Üí 0¬∞';
            document.getElementById('orbitalTilt').textContent = moonTiltInfo;
            
            updateToggleInfo();
        }
        
        // Start
        init();
        updatePositions(0);
        updateUIOnly(0);
        updateCameraModeUI();
        updateSpeedDisplay();
        
        // Ustaw animacjƒô jako uruchomionƒÖ i zaktualizuj przycisk
        lastAnimationTime = performance.now();
        document.getElementById('playButton').textContent = '‚è∏ Pauza';
        
        animate();
    </script>
</body>
</html>